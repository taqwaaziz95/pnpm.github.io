var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};

// ../error/lib/index.js
var require_lib = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.FetchError = void 0;
  var PnpmError = class extends Error {
    constructor(code, message, opts) {
      super(message);
      this.code = `ERR_PNPM_${code}`;
      this.hint = opts === null || opts === void 0 ? void 0 : opts.hint;
      this.attempts = opts === null || opts === void 0 ? void 0 : opts.attempts;
    }
  };
  exports2.default = PnpmError;
  var FetchError = class extends PnpmError {
    constructor(request, response, hint) {
      const message = `GET ${request.url}: ${response.statusText} - ${response.status}`;
      const authHeaderValue = request.authHeaderValue ? hideAuthInformation(request.authHeaderValue) : void 0;
      if (response.status === 401 || response.status === 403 || response.status === 404) {
        hint = hint ? `${hint}

` : "";
        if (authHeaderValue) {
          hint += `An authorization header was used: ${authHeaderValue}`;
        } else {
          hint += "No authorization header was set for the request.";
        }
      }
      super(`FETCH_${response.status}`, message, {hint});
      this.request = request;
      this.response = response;
    }
  };
  exports2.FetchError = FetchError;
  function hideAuthInformation(authHeaderValue) {
    const [authType, token] = authHeaderValue.split(" ");
    return `${authType} ${token.substring(0, 4)}[hidden]`;
  }
});

// ../../node_modules/.pnpm/yocto-queue@0.1.0/node_modules/yocto-queue/index.js
var require_yocto_queue = __commonJS((exports2, module2) => {
  var Node = class {
    constructor(value) {
      this.value = value;
      this.next = void 0;
    }
  };
  var Queue = class {
    constructor() {
      this.clear();
    }
    enqueue(value) {
      const node = new Node(value);
      if (this._head) {
        this._tail.next = node;
        this._tail = node;
      } else {
        this._head = node;
        this._tail = node;
      }
      this._size++;
    }
    dequeue() {
      const current = this._head;
      if (!current) {
        return;
      }
      this._head = this._head.next;
      this._size--;
      return current.value;
    }
    clear() {
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
    }
    get size() {
      return this._size;
    }
    *[Symbol.iterator]() {
      let current = this._head;
      while (current) {
        yield current.value;
        current = current.next;
      }
    }
  };
  module2.exports = Queue;
});

// ../../node_modules/.pnpm/p-limit@3.1.0/node_modules/p-limit/index.js
var require_p_limit = __commonJS((exports2, module2) => {
  "use strict";
  var Queue = require_yocto_queue();
  var pLimit = (concurrency) => {
    if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
      throw new TypeError("Expected `concurrency` to be a number from 1 and up");
    }
    const queue = new Queue();
    let activeCount = 0;
    const next = () => {
      activeCount--;
      if (queue.size > 0) {
        queue.dequeue()();
      }
    };
    const run = async (fn, resolve, ...args) => {
      activeCount++;
      const result = (async () => fn(...args))();
      resolve(result);
      try {
        await result;
      } catch {
      }
      next();
    };
    const enqueue = (fn, resolve, ...args) => {
      queue.enqueue(run.bind(null, fn, resolve, ...args));
      (async () => {
        await Promise.resolve();
        if (activeCount < concurrency && queue.size > 0) {
          queue.dequeue()();
        }
      })();
    };
    const generator = (fn, ...args) => new Promise((resolve) => {
      enqueue(fn, resolve, ...args);
    });
    Object.defineProperties(generator, {
      activeCount: {
        get: () => activeCount
      },
      pendingCount: {
        get: () => queue.size
      },
      clearQueue: {
        value: () => {
          queue.clear();
        }
      }
    });
    return generator;
  };
  module2.exports = pLimit;
});

// ../../node_modules/.pnpm/p-locate@5.0.0/node_modules/p-locate/index.js
var require_p_locate = __commonJS((exports2, module2) => {
  "use strict";
  var pLimit = require_p_limit();
  var EndError = class extends Error {
    constructor(value) {
      super();
      this.value = value;
    }
  };
  var testElement = async (element, tester) => tester(await element);
  var finder = async (element) => {
    const values = await Promise.all(element);
    if (values[1] === true) {
      throw new EndError(values[0]);
    }
    return false;
  };
  var pLocate = async (iterable, tester, options) => {
    options = {
      concurrency: Infinity,
      preserveOrder: true,
      ...options
    };
    const limit = pLimit(options.concurrency);
    const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
    const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
    try {
      await Promise.all(items.map((element) => checkLimit(finder, element)));
    } catch (error) {
      if (error instanceof EndError) {
        return error.value;
      }
      throw error;
    }
  };
  module2.exports = pLocate;
});

// ../../node_modules/.pnpm/locate-path@6.0.0/node_modules/locate-path/index.js
var require_locate_path = __commonJS((exports2, module2) => {
  "use strict";
  var path2 = require("path");
  var fs = require("fs");
  var {promisify} = require("util");
  var pLocate = require_p_locate();
  var fsStat = promisify(fs.stat);
  var fsLStat = promisify(fs.lstat);
  var typeMappings = {
    directory: "isDirectory",
    file: "isFile"
  };
  function checkType({type}) {
    if (type in typeMappings) {
      return;
    }
    throw new Error(`Invalid type specified: ${type}`);
  }
  var matchType = (type, stat) => type === void 0 || stat[typeMappings[type]]();
  module2.exports = async (paths, options) => {
    options = {
      cwd: process.cwd(),
      type: "file",
      allowSymlinks: true,
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fsStat : fsLStat;
    return pLocate(paths, async (path_) => {
      try {
        const stat = await statFn(path2.resolve(options.cwd, path_));
        return matchType(options.type, stat);
      } catch {
        return false;
      }
    }, options);
  };
  module2.exports.sync = (paths, options) => {
    options = {
      cwd: process.cwd(),
      allowSymlinks: true,
      type: "file",
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;
    for (const path_ of paths) {
      try {
        const stat = statFn(path2.resolve(options.cwd, path_));
        if (matchType(options.type, stat)) {
          return path_;
        }
      } catch {
      }
    }
  };
});

// ../../node_modules/.pnpm/path-exists@4.0.0/node_modules/path-exists/index.js
var require_path_exists = __commonJS((exports2, module2) => {
  "use strict";
  var fs = require("fs");
  var {promisify} = require("util");
  var pAccess = promisify(fs.access);
  module2.exports = async (path2) => {
    try {
      await pAccess(path2);
      return true;
    } catch (_) {
      return false;
    }
  };
  module2.exports.sync = (path2) => {
    try {
      fs.accessSync(path2);
      return true;
    } catch (_) {
      return false;
    }
  };
});

// ../../node_modules/.pnpm/find-up@5.0.0/node_modules/find-up/index.js
var require_find_up = __commonJS((exports2, module2) => {
  "use strict";
  var path2 = require("path");
  var locatePath = require_locate_path();
  var pathExists = require_path_exists();
  var stop = Symbol("findUp.stop");
  module2.exports = async (name, options = {}) => {
    let directory = path2.resolve(options.cwd || "");
    const {root} = path2.parse(directory);
    const paths = [].concat(name);
    const runMatcher = async (locateOptions) => {
      if (typeof name !== "function") {
        return locatePath(paths, locateOptions);
      }
      const foundPath = await name(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = await runMatcher({...options, cwd: directory});
      if (foundPath === stop) {
        return;
      }
      if (foundPath) {
        return path2.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path2.dirname(directory);
    }
  };
  module2.exports.sync = (name, options = {}) => {
    let directory = path2.resolve(options.cwd || "");
    const {root} = path2.parse(directory);
    const paths = [].concat(name);
    const runMatcher = (locateOptions) => {
      if (typeof name !== "function") {
        return locatePath.sync(paths, locateOptions);
      }
      const foundPath = name(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath.sync([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = runMatcher({...options, cwd: directory});
      if (foundPath === stop) {
        return;
      }
      if (foundPath) {
        return path2.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path2.dirname(directory);
    }
  };
  module2.exports.exists = pathExists;
  module2.exports.sync.exists = pathExists.sync;
  module2.exports.stop = stop;
});

// ../find-workspace-dir/lib/index.js
var require_lib2 = __commonJS((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var error_1 = __importDefault2(require_lib());
  var path2 = require("path");
  var findUp = require_find_up();
  var WORKSPACE_MANIFEST_FILENAME = "pnpm-workspace.yaml";
  async function findWorkspaceDir(cwd) {
    const workspaceManifestLocation = await findUp([WORKSPACE_MANIFEST_FILENAME, "pnpm-workspace.yml"], {cwd});
    if (workspaceManifestLocation === null || workspaceManifestLocation === void 0 ? void 0 : workspaceManifestLocation.endsWith(".yml")) {
      throw new error_1.default("BAD_WORKSPACE_MANIFEST_NAME", `The workspace manifest file should be named "pnpm-workspace.yaml". File found: ${workspaceManifestLocation}`);
    }
    return workspaceManifestLocation && path2.dirname(workspaceManifestLocation);
  }
  exports2.default = findWorkspaceDir;
});

// ../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports2, module2) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// ../../node_modules/.pnpm/@zkochan#libnpx@11.0.3/node_modules/@zkochan/libnpx/util.js
var require_util = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports.promisify = promisify;
  function promisify(f) {
    const util = require("util");
    if (util.promisify) {
      return util.promisify(f);
    } else {
      return function() {
        return new Promise((resolve, reject) => {
          f.apply(this, [].slice.call(arguments).concat((err, val) => {
            err ? reject(err) : resolve(val);
          }));
        });
      };
    }
  }
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/common-types.js
var require_common_types = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.objectKeys = exports2.assertSingleKey = exports2.assertNotStrictEqual = void 0;
  var assert_1 = require("assert");
  function assertNotStrictEqual(actual, expected, message) {
    assert_1.notStrictEqual(actual, expected, message);
  }
  exports2.assertNotStrictEqual = assertNotStrictEqual;
  function assertSingleKey(actual) {
    assert_1.strictEqual(typeof actual, "string");
  }
  exports2.assertSingleKey = assertSingleKey;
  function objectKeys(object) {
    return Object.keys(object);
  }
  exports2.objectKeys = objectKeys;
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/is-promise.js
var require_is_promise = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.isPromise = void 0;
  function isPromise(maybePromise) {
    return !!maybePromise && !!maybePromise.then && typeof maybePromise.then === "function";
  }
  exports2.isPromise = isPromise;
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/yerror.js
var require_yerror = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.YError = void 0;
  var YError = class extends Error {
    constructor(msg) {
      super(msg || "yargs error");
      this.name = "YError";
      Error.captureStackTrace(this, YError);
    }
  };
  exports2.YError = YError;
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/parse-command.js
var require_parse_command = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.parseCommand = void 0;
  function parseCommand(cmd) {
    const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, " ");
    const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
    const bregex = /\.*[\][<>]/g;
    const firstCommand = splitCommand.shift();
    if (!firstCommand)
      throw new Error(`No command found in: ${cmd}`);
    const parsedCommand = {
      cmd: firstCommand.replace(bregex, ""),
      demanded: [],
      optional: []
    };
    splitCommand.forEach((cmd2, i) => {
      let variadic = false;
      cmd2 = cmd2.replace(/\s/g, "");
      if (/\.+[\]>]/.test(cmd2) && i === splitCommand.length - 1)
        variadic = true;
      if (/^\[/.test(cmd2)) {
        parsedCommand.optional.push({
          cmd: cmd2.replace(bregex, "").split("|"),
          variadic
        });
      } else {
        parsedCommand.demanded.push({
          cmd: cmd2.replace(bregex, "").split("|"),
          variadic
        });
      }
    });
    return parsedCommand;
  }
  exports2.parseCommand = parseCommand;
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/argsert.js
var require_argsert = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.argsert = void 0;
  var yerror_1 = require_yerror();
  var parse_command_1 = require_parse_command();
  var positionName = ["first", "second", "third", "fourth", "fifth", "sixth"];
  function argsert(arg1, arg2, arg3) {
    function parseArgs() {
      return typeof arg1 === "object" ? [{demanded: [], optional: []}, arg1, arg2] : [parse_command_1.parseCommand(`cmd ${arg1}`), arg2, arg3];
    }
    try {
      let position = 0;
      let [parsed, callerArguments, length] = parseArgs();
      const args = [].slice.call(callerArguments);
      while (args.length && args[args.length - 1] === void 0)
        args.pop();
      length = length || args.length;
      if (length < parsed.demanded.length) {
        throw new yerror_1.YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);
      }
      const totalCommands = parsed.demanded.length + parsed.optional.length;
      if (length > totalCommands) {
        throw new yerror_1.YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);
      }
      parsed.demanded.forEach((demanded) => {
        const arg = args.shift();
        const observedType = guessType(arg);
        const matchingTypes = demanded.cmd.filter((type) => type === observedType || type === "*");
        if (matchingTypes.length === 0)
          argumentTypeError(observedType, demanded.cmd, position);
        position += 1;
      });
      parsed.optional.forEach((optional) => {
        if (args.length === 0)
          return;
        const arg = args.shift();
        const observedType = guessType(arg);
        const matchingTypes = optional.cmd.filter((type) => type === observedType || type === "*");
        if (matchingTypes.length === 0)
          argumentTypeError(observedType, optional.cmd, position);
        position += 1;
      });
    } catch (err) {
      console.warn(err.stack);
    }
  }
  exports2.argsert = argsert;
  function guessType(arg) {
    if (Array.isArray(arg)) {
      return "array";
    } else if (arg === null) {
      return "null";
    }
    return typeof arg;
  }
  function argumentTypeError(observedType, allowedTypes, position) {
    throw new yerror_1.YError(`Invalid ${positionName[position] || "manyith"} argument. Expected ${allowedTypes.join(" or ")} but received ${observedType}.`);
  }
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/middleware.js
var require_middleware = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.applyMiddleware = exports2.commandMiddlewareFactory = exports2.globalMiddlewareFactory = void 0;
  var argsert_1 = require_argsert();
  var is_promise_1 = require_is_promise();
  function globalMiddlewareFactory(globalMiddleware, context) {
    return function(callback, applyBeforeValidation = false) {
      argsert_1.argsert("<array|function> [boolean]", [callback, applyBeforeValidation], arguments.length);
      if (Array.isArray(callback)) {
        for (let i = 0; i < callback.length; i++) {
          if (typeof callback[i] !== "function") {
            throw Error("middleware must be a function");
          }
          callback[i].applyBeforeValidation = applyBeforeValidation;
        }
        Array.prototype.push.apply(globalMiddleware, callback);
      } else if (typeof callback === "function") {
        callback.applyBeforeValidation = applyBeforeValidation;
        globalMiddleware.push(callback);
      }
      return context;
    };
  }
  exports2.globalMiddlewareFactory = globalMiddlewareFactory;
  function commandMiddlewareFactory(commandMiddleware) {
    if (!commandMiddleware)
      return [];
    return commandMiddleware.map((middleware) => {
      middleware.applyBeforeValidation = false;
      return middleware;
    });
  }
  exports2.commandMiddlewareFactory = commandMiddlewareFactory;
  function applyMiddleware(argv, yargs, middlewares, beforeValidation) {
    const beforeValidationError = new Error("middleware cannot return a promise when applyBeforeValidation is true");
    return middlewares.reduce((acc, middleware) => {
      if (middleware.applyBeforeValidation !== beforeValidation) {
        return acc;
      }
      if (is_promise_1.isPromise(acc)) {
        return acc.then((initialObj) => Promise.all([initialObj, middleware(initialObj, yargs)])).then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));
      } else {
        const result = middleware(acc, yargs);
        if (beforeValidation && is_promise_1.isPromise(result))
          throw beforeValidationError;
        return is_promise_1.isPromise(result) ? result.then((middlewareObj) => Object.assign(acc, middlewareObj)) : Object.assign(acc, result);
      }
    }, argv);
  }
  exports2.applyMiddleware = applyMiddleware;
});

// ../../node_modules/.pnpm/require-directory@2.1.1/node_modules/require-directory/index.js
var require_require_directory = __commonJS((exports2, module2) => {
  "use strict";
  var fs = require("fs");
  var join = require("path").join;
  var resolve = require("path").resolve;
  var dirname = require("path").dirname;
  var defaultOptions = {
    extensions: ["js", "json", "coffee"],
    recurse: true,
    rename: function(name) {
      return name;
    },
    visit: function(obj) {
      return obj;
    }
  };
  function checkFileInclusion(path2, filename, options) {
    return new RegExp("\\.(" + options.extensions.join("|") + ")$", "i").test(filename) && !(options.include && options.include instanceof RegExp && !options.include.test(path2)) && !(options.include && typeof options.include === "function" && !options.include(path2, filename)) && !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path2)) && !(options.exclude && typeof options.exclude === "function" && options.exclude(path2, filename));
  }
  function requireDirectory(m, path2, options) {
    var retval = {};
    if (path2 && !options && typeof path2 !== "string") {
      options = path2;
      path2 = null;
    }
    options = options || {};
    for (var prop in defaultOptions) {
      if (typeof options[prop] === "undefined") {
        options[prop] = defaultOptions[prop];
      }
    }
    path2 = !path2 ? dirname(m.filename) : resolve(dirname(m.filename), path2);
    fs.readdirSync(path2).forEach(function(filename) {
      var joined = join(path2, filename), files, key, obj;
      if (fs.statSync(joined).isDirectory() && options.recurse) {
        files = requireDirectory(m, joined, options);
        if (Object.keys(files).length) {
          retval[options.rename(filename, joined, filename)] = files;
        }
      } else {
        if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {
          key = filename.substring(0, filename.lastIndexOf("."));
          obj = m.require(joined);
          retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;
        }
      }
    });
    return retval;
  }
  module2.exports = requireDirectory;
  module2.exports.defaults = defaultOptions;
});

// ../../node_modules/.pnpm/which-module@2.0.0/node_modules/which-module/index.js
var require_which_module = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function whichModule(exported) {
    for (var i = 0, files = Object.keys(require.cache), mod; i < files.length; i++) {
      mod = require.cache[files[i]];
      if (mod.exports === exported)
        return mod;
    }
    return null;
  };
});

// ../../node_modules/.pnpm/camelcase@5.3.1/node_modules/camelcase/index.js
var require_camelcase = __commonJS((exports2, module2) => {
  "use strict";
  var preserveCamelCase = (string) => {
    let isLastCharLower = false;
    let isLastCharUpper = false;
    let isLastLastCharUpper = false;
    for (let i = 0; i < string.length; i++) {
      const character = string[i];
      if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
        string = string.slice(0, i) + "-" + string.slice(i);
        isLastCharLower = false;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = true;
        i++;
      } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
        string = string.slice(0, i - 1) + "-" + string.slice(i - 1);
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = false;
        isLastCharLower = true;
      } else {
        isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
      }
    }
    return string;
  };
  var camelCase = (input, options) => {
    if (!(typeof input === "string" || Array.isArray(input))) {
      throw new TypeError("Expected the input to be `string | string[]`");
    }
    options = Object.assign({
      pascalCase: false
    }, options);
    const postProcess = (x) => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;
    if (Array.isArray(input)) {
      input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
    } else {
      input = input.trim();
    }
    if (input.length === 0) {
      return "";
    }
    if (input.length === 1) {
      return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
    }
    const hasUpperCase = input !== input.toLowerCase();
    if (hasUpperCase) {
      input = preserveCamelCase(input);
    }
    input = input.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase()).replace(/\d+(\w|$)/g, (m) => m.toUpperCase());
    return postProcess(input);
  };
  module2.exports = camelCase;
  module2.exports.default = camelCase;
});

// ../../node_modules/.pnpm/decamelize@1.2.0/node_modules/decamelize/index.js
var require_decamelize = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(str, sep) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    sep = typeof sep === "undefined" ? "_" : sep;
    return str.replace(/([a-z\d])([A-Z])/g, "$1" + sep + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + sep + "$2").toLowerCase();
  };
});

// ../../node_modules/.pnpm/yargs-parser@18.1.3/node_modules/yargs-parser/lib/tokenize-arg-string.js
var require_tokenize_arg_string = __commonJS((exports2, module2) => {
  module2.exports = function(argString) {
    if (Array.isArray(argString)) {
      return argString.map((e) => typeof e !== "string" ? e + "" : e);
    }
    argString = argString.trim();
    let i = 0;
    let prevC = null;
    let c = null;
    let opening = null;
    const args = [];
    for (let ii = 0; ii < argString.length; ii++) {
      prevC = c;
      c = argString.charAt(ii);
      if (c === " " && !opening) {
        if (!(prevC === " ")) {
          i++;
        }
        continue;
      }
      if (c === opening) {
        opening = null;
      } else if ((c === "'" || c === '"') && !opening) {
        opening = c;
      }
      if (!args[i])
        args[i] = "";
      args[i] += c;
    }
    return args;
  };
});

// ../../node_modules/.pnpm/yargs-parser@18.1.3/node_modules/yargs-parser/index.js
var require_yargs_parser = __commonJS((exports2, module2) => {
  var camelCase = require_camelcase();
  var decamelize = require_decamelize();
  var path2 = require("path");
  var tokenizeArgString = require_tokenize_arg_string();
  var util = require("util");
  function parse(args, opts) {
    opts = Object.assign(Object.create(null), opts);
    args = tokenizeArgString(args);
    const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
    const configuration = Object.assign({
      "boolean-negation": true,
      "camel-case-expansion": true,
      "combine-arrays": false,
      "dot-notation": true,
      "duplicate-arguments-array": true,
      "flatten-duplicate-arrays": true,
      "greedy-arrays": true,
      "halt-at-non-option": false,
      "nargs-eats-options": false,
      "negation-prefix": "no-",
      "parse-numbers": true,
      "populate--": false,
      "set-placeholder-key": false,
      "short-option-groups": true,
      "strip-aliased": false,
      "strip-dashed": false,
      "unknown-options-as-args": false
    }, opts.configuration);
    const defaults = Object.assign(Object.create(null), opts.default);
    const configObjects = opts.configObjects || [];
    const envPrefix = opts.envPrefix;
    const notFlagsOption = configuration["populate--"];
    const notFlagsArgv = notFlagsOption ? "--" : "_";
    const newAliases = Object.create(null);
    const defaulted = Object.create(null);
    const __ = opts.__ || util.format;
    const flags = {
      aliases: Object.create(null),
      arrays: Object.create(null),
      bools: Object.create(null),
      strings: Object.create(null),
      numbers: Object.create(null),
      counts: Object.create(null),
      normalize: Object.create(null),
      configs: Object.create(null),
      nargs: Object.create(null),
      coercions: Object.create(null),
      keys: []
    };
    const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
    const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
    [].concat(opts.array).filter(Boolean).forEach(function(opt) {
      const key = opt.key || opt;
      const assignment = Object.keys(opt).map(function(key2) {
        return {
          boolean: "bools",
          string: "strings",
          number: "numbers"
        }[key2];
      }).filter(Boolean).pop();
      if (assignment) {
        flags[assignment][key] = true;
      }
      flags.arrays[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.boolean).filter(Boolean).forEach(function(key) {
      flags.bools[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.string).filter(Boolean).forEach(function(key) {
      flags.strings[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.number).filter(Boolean).forEach(function(key) {
      flags.numbers[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.count).filter(Boolean).forEach(function(key) {
      flags.counts[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.normalize).filter(Boolean).forEach(function(key) {
      flags.normalize[key] = true;
      flags.keys.push(key);
    });
    Object.keys(opts.narg || {}).forEach(function(k) {
      flags.nargs[k] = opts.narg[k];
      flags.keys.push(k);
    });
    Object.keys(opts.coerce || {}).forEach(function(k) {
      flags.coercions[k] = opts.coerce[k];
      flags.keys.push(k);
    });
    if (Array.isArray(opts.config) || typeof opts.config === "string") {
      ;
      [].concat(opts.config).filter(Boolean).forEach(function(key) {
        flags.configs[key] = true;
      });
    } else {
      Object.keys(opts.config || {}).forEach(function(k) {
        flags.configs[k] = opts.config[k];
      });
    }
    extendAliases(opts.key, aliases, opts.default, flags.arrays);
    Object.keys(defaults).forEach(function(key) {
      (flags.aliases[key] || []).forEach(function(alias) {
        defaults[alias] = defaults[key];
      });
    });
    let error = null;
    checkConfiguration();
    let notFlags = [];
    const argv = Object.assign(Object.create(null), {_: []});
    const argvReturn = {};
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      let broken;
      let key;
      let letters;
      let m;
      let next;
      let value;
      if (arg !== "--" && isUnknownOptionAsArg(arg)) {
        argv._.push(arg);
      } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
        m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
        if (checkAllAliases(m[1], flags.arrays)) {
          i = eatArray(i, m[1], args, m[2]);
        } else if (checkAllAliases(m[1], flags.nargs) !== false) {
          i = eatNargs(i, m[1], args, m[2]);
        } else {
          setArg(m[1], m[2]);
        }
      } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
        key = arg.match(negatedBoolean)[1];
        setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
      } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
        key = arg.match(/^--?(.+)/)[1];
        if (checkAllAliases(key, flags.arrays)) {
          i = eatArray(i, key, args);
        } else if (checkAllAliases(key, flags.nargs) !== false) {
          i = eatNargs(i, key, args);
        } else {
          next = args[i + 1];
          if (next !== void 0 && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
            setArg(key, next);
            i++;
          } else if (/^(true|false)$/.test(next)) {
            setArg(key, next);
            i++;
          } else {
            setArg(key, defaultValue(key));
          }
        }
      } else if (arg.match(/^-.\..+=/)) {
        m = arg.match(/^-([^=]+)=([\s\S]*)$/);
        setArg(m[1], m[2]);
      } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
        next = args[i + 1];
        key = arg.match(/^-(.\..+)/)[1];
        if (next !== void 0 && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
          setArg(key, next);
          i++;
        } else {
          setArg(key, defaultValue(key));
        }
      } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
        letters = arg.slice(1, -1).split("");
        broken = false;
        for (let j = 0; j < letters.length; j++) {
          next = arg.slice(j + 2);
          if (letters[j + 1] && letters[j + 1] === "=") {
            value = arg.slice(j + 3);
            key = letters[j];
            if (checkAllAliases(key, flags.arrays)) {
              i = eatArray(i, key, args, value);
            } else if (checkAllAliases(key, flags.nargs) !== false) {
              i = eatNargs(i, key, args, value);
            } else {
              setArg(key, value);
            }
            broken = true;
            break;
          }
          if (next === "-") {
            setArg(letters[j], next);
            continue;
          }
          if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
            setArg(letters[j], next);
            broken = true;
            break;
          }
          if (letters[j + 1] && letters[j + 1].match(/\W/)) {
            setArg(letters[j], next);
            broken = true;
            break;
          } else {
            setArg(letters[j], defaultValue(letters[j]));
          }
        }
        key = arg.slice(-1)[0];
        if (!broken && key !== "-") {
          if (checkAllAliases(key, flags.arrays)) {
            i = eatArray(i, key, args);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i = eatNargs(i, key, args);
          } else {
            next = args[i + 1];
            if (next !== void 0 && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
        key = arg.slice(1);
        setArg(key, defaultValue(key));
      } else if (arg === "--") {
        notFlags = args.slice(i + 1);
        break;
      } else if (configuration["halt-at-non-option"]) {
        notFlags = args.slice(i);
        break;
      } else {
        argv._.push(maybeCoerceNumber("_", arg));
      }
    }
    applyEnvVars(argv, true);
    applyEnvVars(argv, false);
    setConfig(argv);
    setConfigObjects();
    applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
    applyCoercions(argv);
    if (configuration["set-placeholder-key"])
      setPlaceholderKeys(argv);
    Object.keys(flags.counts).forEach(function(key) {
      if (!hasKey(argv, key.split(".")))
        setArg(key, 0);
    });
    if (notFlagsOption && notFlags.length)
      argv[notFlagsArgv] = [];
    notFlags.forEach(function(key) {
      argv[notFlagsArgv].push(key);
    });
    if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
      Object.keys(argv).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
        delete argv[key];
      });
    }
    if (configuration["strip-aliased"]) {
      ;
      [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
        if (configuration["camel-case-expansion"]) {
          delete argv[alias.split(".").map((prop) => camelCase(prop)).join(".")];
        }
        delete argv[alias];
      });
    }
    function eatNargs(i, key, args2, argAfterEqualSign) {
      let ii;
      let toEat = checkAllAliases(key, flags.nargs);
      toEat = isNaN(toEat) ? 1 : toEat;
      if (toEat === 0) {
        if (!isUndefined(argAfterEqualSign)) {
          error = Error(__("Argument unexpected for: %s", key));
        }
        setArg(key, defaultValue(key));
        return i;
      }
      let available = isUndefined(argAfterEqualSign) ? 0 : 1;
      if (configuration["nargs-eats-options"]) {
        if (args2.length - (i + 1) + available < toEat) {
          error = Error(__("Not enough arguments following: %s", key));
        }
        available = toEat;
      } else {
        for (ii = i + 1; ii < args2.length; ii++) {
          if (!args2[ii].match(/^-[^0-9]/) || args2[ii].match(negative) || isUnknownOptionAsArg(args2[ii]))
            available++;
          else
            break;
        }
        if (available < toEat)
          error = Error(__("Not enough arguments following: %s", key));
      }
      let consumed = Math.min(available, toEat);
      if (!isUndefined(argAfterEqualSign) && consumed > 0) {
        setArg(key, argAfterEqualSign);
        consumed--;
      }
      for (ii = i + 1; ii < consumed + i + 1; ii++) {
        setArg(key, args2[ii]);
      }
      return i + consumed;
    }
    function eatArray(i, key, args2, argAfterEqualSign) {
      let argsToSet = [];
      let next = argAfterEqualSign || args2[i + 1];
      const nargsCount = checkAllAliases(key, flags.nargs);
      if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
        argsToSet.push(true);
      } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
        if (defaults[key] !== void 0) {
          const defVal = defaults[key];
          argsToSet = Array.isArray(defVal) ? defVal : [defVal];
        }
      } else {
        if (!isUndefined(argAfterEqualSign)) {
          argsToSet.push(processValue(key, argAfterEqualSign));
        }
        for (let ii = i + 1; ii < args2.length; ii++) {
          if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && argsToSet.length >= nargsCount)
            break;
          next = args2[ii];
          if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
            break;
          i = ii;
          argsToSet.push(processValue(key, next));
        }
      }
      if (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0) {
        error = Error(__("Not enough arguments following: %s", key));
      }
      setArg(key, argsToSet);
      return i;
    }
    function setArg(key, val) {
      if (/-/.test(key) && configuration["camel-case-expansion"]) {
        const alias = key.split(".").map(function(prop) {
          return camelCase(prop);
        }).join(".");
        addNewAlias(key, alias);
      }
      const value = processValue(key, val);
      const splitKey = key.split(".");
      setKey(argv, splitKey, value);
      if (flags.aliases[key]) {
        flags.aliases[key].forEach(function(x) {
          x = x.split(".");
          setKey(argv, x, value);
        });
      }
      if (splitKey.length > 1 && configuration["dot-notation"]) {
        ;
        (flags.aliases[splitKey[0]] || []).forEach(function(x) {
          x = x.split(".");
          const a = [].concat(splitKey);
          a.shift();
          x = x.concat(a);
          if (!(flags.aliases[key] || []).includes(x.join("."))) {
            setKey(argv, x, value);
          }
        });
      }
      if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
        const keys = [key].concat(flags.aliases[key] || []);
        keys.forEach(function(key2) {
          Object.defineProperty(argvReturn, key2, {
            enumerable: true,
            get() {
              return val;
            },
            set(value2) {
              val = typeof value2 === "string" ? path2.normalize(value2) : value2;
            }
          });
        });
      }
    }
    function addNewAlias(key, alias) {
      if (!(flags.aliases[key] && flags.aliases[key].length)) {
        flags.aliases[key] = [alias];
        newAliases[alias] = true;
      }
      if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
        addNewAlias(alias, key);
      }
    }
    function processValue(key, val) {
      if (typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0]) {
        val = val.substring(1, val.length - 1);
      }
      if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
        if (typeof val === "string")
          val = val === "true";
      }
      let value = Array.isArray(val) ? val.map(function(v) {
        return maybeCoerceNumber(key, v);
      }) : maybeCoerceNumber(key, val);
      if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === "boolean")) {
        value = increment;
      }
      if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
        if (Array.isArray(val))
          value = val.map(path2.normalize);
        else
          value = path2.normalize(val);
      }
      return value;
    }
    function maybeCoerceNumber(key, value) {
      if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
        const shouldCoerceNumber = isNumber(value) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(value));
        if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers))
          value = Number(value);
      }
      return value;
    }
    function setConfig(argv2) {
      const configLookup = Object.create(null);
      applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
      Object.keys(flags.configs).forEach(function(configKey) {
        const configPath = argv2[configKey] || configLookup[configKey];
        if (configPath) {
          try {
            let config = null;
            const resolvedConfigPath = path2.resolve(process.cwd(), configPath);
            if (typeof flags.configs[configKey] === "function") {
              try {
                config = flags.configs[configKey](resolvedConfigPath);
              } catch (e) {
                config = e;
              }
              if (config instanceof Error) {
                error = config;
                return;
              }
            } else {
              config = require(resolvedConfigPath);
            }
            setConfigObject(config);
          } catch (ex) {
            if (argv2[configKey])
              error = Error(__("Invalid JSON config file: %s", configPath));
          }
        }
      });
    }
    function setConfigObject(config, prev) {
      Object.keys(config).forEach(function(key) {
        const value = config[key];
        const fullKey = prev ? prev + "." + key : key;
        if (typeof value === "object" && value !== null && !Array.isArray(value) && configuration["dot-notation"]) {
          setConfigObject(value, fullKey);
        } else {
          if (!hasKey(argv, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
            setArg(fullKey, value);
          }
        }
      });
    }
    function setConfigObjects() {
      if (typeof configObjects === "undefined")
        return;
      configObjects.forEach(function(configObject) {
        setConfigObject(configObject);
      });
    }
    function applyEnvVars(argv2, configOnly) {
      if (typeof envPrefix === "undefined")
        return;
      const prefix = typeof envPrefix === "string" ? envPrefix : "";
      Object.keys(process.env).forEach(function(envVar) {
        if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
          const keys = envVar.split("__").map(function(key, i) {
            if (i === 0) {
              key = key.substring(prefix.length);
            }
            return camelCase(key);
          });
          if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv2, keys)) {
            setArg(keys.join("."), process.env[envVar]);
          }
        }
      });
    }
    function applyCoercions(argv2) {
      let coerce;
      const applied = new Set();
      Object.keys(argv2).forEach(function(key) {
        if (!applied.has(key)) {
          coerce = checkAllAliases(key, flags.coercions);
          if (typeof coerce === "function") {
            try {
              const value = maybeCoerceNumber(key, coerce(argv2[key]));
              [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                applied.add(ali);
                argv2[ali] = value;
              });
            } catch (err) {
              error = err;
            }
          }
        }
      });
    }
    function setPlaceholderKeys(argv2) {
      flags.keys.forEach((key) => {
        if (~key.indexOf("."))
          return;
        if (typeof argv2[key] === "undefined")
          argv2[key] = void 0;
      });
      return argv2;
    }
    function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
      Object.keys(defaults2).forEach(function(key) {
        if (!hasKey(obj, key.split("."))) {
          setKey(obj, key.split("."), defaults2[key]);
          if (canLog)
            defaulted[key] = true;
          (aliases2[key] || []).forEach(function(x) {
            if (hasKey(obj, x.split(".")))
              return;
            setKey(obj, x.split("."), defaults2[key]);
          });
        }
      });
    }
    function hasKey(obj, keys) {
      let o = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      const key = keys[keys.length - 1];
      if (typeof o !== "object")
        return false;
      else
        return key in o;
    }
    function setKey(obj, keys, value) {
      let o = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2, index) {
        key2 = sanitizeKey(key2);
        if (typeof o === "object" && o[key2] === void 0) {
          o[key2] = {};
        }
        if (typeof o[key2] !== "object" || Array.isArray(o[key2])) {
          if (Array.isArray(o[key2])) {
            o[key2].push({});
          } else {
            o[key2] = [o[key2], {}];
          }
          o = o[key2][o[key2].length - 1];
        } else {
          o = o[key2];
        }
      });
      const key = sanitizeKey(keys[keys.length - 1]);
      const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
      const isValueArray = Array.isArray(value);
      let duplicate = configuration["duplicate-arguments-array"];
      if (!duplicate && checkAllAliases(key, flags.nargs)) {
        duplicate = true;
        if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
          o[key] = void 0;
        }
      }
      if (value === increment) {
        o[key] = increment(o[key]);
      } else if (Array.isArray(o[key])) {
        if (duplicate && isTypeArray && isValueArray) {
          o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
        } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
          o[key] = value;
        } else {
          o[key] = o[key].concat([value]);
        }
      } else if (o[key] === void 0 && isTypeArray) {
        o[key] = isValueArray ? value : [value];
      } else if (duplicate && !(o[key] === void 0 || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
        o[key] = [o[key], value];
      } else {
        o[key] = value;
      }
    }
    function extendAliases(...args2) {
      args2.forEach(function(obj) {
        Object.keys(obj || {}).forEach(function(key) {
          if (flags.aliases[key])
            return;
          flags.aliases[key] = [].concat(aliases[key] || []);
          flags.aliases[key].concat(key).forEach(function(x) {
            if (/-/.test(x) && configuration["camel-case-expansion"]) {
              const c = camelCase(x);
              if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                flags.aliases[key].push(c);
                newAliases[c] = true;
              }
            }
          });
          flags.aliases[key].concat(key).forEach(function(x) {
            if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
              const c = decamelize(x, "-");
              if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                flags.aliases[key].push(c);
                newAliases[c] = true;
              }
            }
          });
          flags.aliases[key].forEach(function(x) {
            flags.aliases[x] = [key].concat(flags.aliases[key].filter(function(y) {
              return x !== y;
            }));
          });
        });
      });
    }
    function checkAllAliases(key, flag) {
      const toCheck = [].concat(flags.aliases[key] || [], key);
      const keys = Object.keys(flag);
      const setAlias = toCheck.find((key2) => keys.includes(key2));
      return setAlias ? flag[setAlias] : false;
    }
    function hasAnyFlag(key) {
      const toCheck = [].concat(Object.keys(flags).map((k) => flags[k]));
      return toCheck.some(function(flag) {
        return Array.isArray(flag) ? flag.includes(key) : flag[key];
      });
    }
    function hasFlagsMatching(arg, ...patterns) {
      const toCheck = [].concat(...patterns);
      return toCheck.some(function(pattern) {
        const match = arg.match(pattern);
        return match && hasAnyFlag(match[1]);
      });
    }
    function hasAllShortFlags(arg) {
      if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
        return false;
      }
      let hasAllFlags = true;
      let next;
      const letters = arg.slice(1).split("");
      for (let j = 0; j < letters.length; j++) {
        next = arg.slice(j + 2);
        if (!hasAnyFlag(letters[j])) {
          hasAllFlags = false;
          break;
        }
        if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
          break;
        }
      }
      return hasAllFlags;
    }
    function isUnknownOptionAsArg(arg) {
      return configuration["unknown-options-as-args"] && isUnknownOption(arg);
    }
    function isUnknownOption(arg) {
      if (arg.match(negative)) {
        return false;
      }
      if (hasAllShortFlags(arg)) {
        return false;
      }
      const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
      const normalFlag = /^-+([^=]+?)$/;
      const flagEndingInHyphen = /^-+([^=]+?)-$/;
      const flagEndingInDigits = /^-+([^=]+?\d+)$/;
      const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
      return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
    }
    function defaultValue(key) {
      if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
        return defaults[key];
      } else {
        return defaultForType(guessType(key));
      }
    }
    function defaultForType(type) {
      const def = {
        boolean: true,
        string: "",
        number: void 0,
        array: []
      };
      return def[type];
    }
    function guessType(key) {
      let type = "boolean";
      if (checkAllAliases(key, flags.strings))
        type = "string";
      else if (checkAllAliases(key, flags.numbers))
        type = "number";
      else if (checkAllAliases(key, flags.bools))
        type = "boolean";
      else if (checkAllAliases(key, flags.arrays))
        type = "array";
      return type;
    }
    function isNumber(x) {
      if (x === null || x === void 0)
        return false;
      if (typeof x === "number")
        return true;
      if (/^0x[0-9a-f]+$/i.test(x))
        return true;
      if (x.length > 1 && x[0] === "0")
        return false;
      return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function isUndefined(num) {
      return num === void 0;
    }
    function checkConfiguration() {
      Object.keys(flags.counts).find((key) => {
        if (checkAllAliases(key, flags.arrays)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
          return true;
        } else if (checkAllAliases(key, flags.nargs)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
          return true;
        }
      });
    }
    return {
      argv: Object.assign(argvReturn, argv),
      error,
      aliases: Object.assign({}, flags.aliases),
      newAliases: Object.assign({}, newAliases),
      defaulted: Object.assign({}, defaulted),
      configuration
    };
  }
  function combineAliases(aliases) {
    const aliasArrays = [];
    const combined = Object.create(null);
    let change = true;
    Object.keys(aliases).forEach(function(key) {
      aliasArrays.push([].concat(aliases[key], key));
    });
    while (change) {
      change = false;
      for (let i = 0; i < aliasArrays.length; i++) {
        for (let ii = i + 1; ii < aliasArrays.length; ii++) {
          const intersect = aliasArrays[i].filter(function(v) {
            return aliasArrays[ii].indexOf(v) !== -1;
          });
          if (intersect.length) {
            aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
            aliasArrays.splice(ii, 1);
            change = true;
            break;
          }
        }
      }
    }
    aliasArrays.forEach(function(aliasArray) {
      aliasArray = aliasArray.filter(function(v, i, self) {
        return self.indexOf(v) === i;
      });
      combined[aliasArray.pop()] = aliasArray;
    });
    return combined;
  }
  function increment(orig) {
    return orig !== void 0 ? orig + 1 : 1;
  }
  function Parser(args, opts) {
    const result = parse(args.slice(), opts);
    return result.argv;
  }
  Parser.detailed = function(args, opts) {
    return parse(args.slice(), opts);
  };
  function sanitizeKey(key) {
    if (key === "__proto__")
      return "___proto___";
    return key;
  }
  module2.exports = Parser;
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/command.js
var require_command = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.isCommandBuilderCallback = exports2.isCommandBuilderDefinition = exports2.isCommandHandlerDefinition = exports2.command = void 0;
  var common_types_1 = require_common_types();
  var is_promise_1 = require_is_promise();
  var middleware_1 = require_middleware();
  var parse_command_1 = require_parse_command();
  var path2 = require("path");
  var util_1 = require("util");
  var yargs_1 = require_yargs();
  var requireDirectory = require_require_directory();
  var whichModule = require_which_module();
  var Parser = require_yargs_parser();
  var DEFAULT_MARKER = /(^\*)|(^\$0)/;
  function command(yargs, usage, validation, globalMiddleware = []) {
    const self = {};
    let handlers = {};
    let aliasMap = {};
    let defaultCommand;
    self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
      let aliases = [];
      const middlewares = middleware_1.commandMiddlewareFactory(commandMiddleware);
      handler = handler || (() => {
      });
      if (Array.isArray(cmd)) {
        aliases = cmd.slice(1);
        cmd = cmd[0];
      } else if (isCommandHandlerDefinition(cmd)) {
        let command2 = Array.isArray(cmd.command) || typeof cmd.command === "string" ? cmd.command : moduleName(cmd);
        if (cmd.aliases)
          command2 = [].concat(command2).concat(cmd.aliases);
        self.addHandler(command2, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
        return;
      }
      if (isCommandBuilderDefinition(builder)) {
        self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
        return;
      }
      const parsedCommand = parse_command_1.parseCommand(cmd);
      aliases = aliases.map((alias) => parse_command_1.parseCommand(alias).cmd);
      let isDefault = false;
      const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {
        if (DEFAULT_MARKER.test(c)) {
          isDefault = true;
          return false;
        }
        return true;
      });
      if (parsedAliases.length === 0 && isDefault)
        parsedAliases.push("$0");
      if (isDefault) {
        parsedCommand.cmd = parsedAliases[0];
        aliases = parsedAliases.slice(1);
        cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
      }
      aliases.forEach((alias) => {
        aliasMap[alias] = parsedCommand.cmd;
      });
      if (description !== false) {
        usage.command(cmd, description, isDefault, aliases, deprecated);
      }
      handlers[parsedCommand.cmd] = {
        original: cmd,
        description,
        handler,
        builder: builder || {},
        middlewares,
        deprecated,
        demanded: parsedCommand.demanded,
        optional: parsedCommand.optional
      };
      if (isDefault)
        defaultCommand = handlers[parsedCommand.cmd];
    };
    self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {
      opts = opts || {};
      if (typeof opts.recurse !== "boolean")
        opts.recurse = false;
      if (!Array.isArray(opts.extensions))
        opts.extensions = ["js"];
      const parentVisit = typeof opts.visit === "function" ? opts.visit : (o) => o;
      opts.visit = function visit(obj, joined, filename) {
        const visited = parentVisit(obj, joined, filename);
        if (visited) {
          if (~context.files.indexOf(joined))
            return visited;
          context.files.push(joined);
          self.addHandler(visited);
        }
        return visited;
      };
      requireDirectory({require: req, filename: callerFile}, dir, opts);
    };
    function moduleName(obj) {
      const mod = whichModule(obj);
      if (!mod)
        throw new Error(`No command name given for module: ${util_1.inspect(obj)}`);
      return commandFromFilename(mod.filename);
    }
    function commandFromFilename(filename) {
      return path2.basename(filename, path2.extname(filename));
    }
    function extractDesc({describe, description, desc}) {
      for (const test of [describe, description, desc]) {
        if (typeof test === "string" || test === false)
          return test;
        common_types_1.assertNotStrictEqual(test, true);
      }
      return false;
    }
    self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));
    self.getCommandHandlers = () => handlers;
    self.hasDefaultCommand = () => !!defaultCommand;
    self.runCommand = function runCommand(command2, yargs2, parsed, commandIndex) {
      let aliases = parsed.aliases;
      const commandHandler = handlers[command2] || handlers[aliasMap[command2]] || defaultCommand;
      const currentContext = yargs2.getContext();
      let numFiles = currentContext.files.length;
      const parentCommands = currentContext.commands.slice();
      let innerArgv = parsed.argv;
      let positionalMap = {};
      if (command2) {
        currentContext.commands.push(command2);
        currentContext.fullCommands.push(commandHandler.original);
      }
      const builder = commandHandler.builder;
      if (isCommandBuilderCallback(builder)) {
        const builderOutput = builder(yargs2.reset(parsed.aliases));
        const innerYargs = yargs_1.isYargsInstance(builderOutput) ? builderOutput : yargs2;
        if (shouldUpdateUsage(innerYargs)) {
          innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
        }
        innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);
        aliases = innerYargs.parsed.aliases;
      } else if (isCommandBuilderOptionDefinitions(builder)) {
        const innerYargs = yargs2.reset(parsed.aliases);
        if (shouldUpdateUsage(innerYargs)) {
          innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
        }
        Object.keys(commandHandler.builder).forEach((key) => {
          innerYargs.option(key, builder[key]);
        });
        innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);
        aliases = innerYargs.parsed.aliases;
      }
      if (!yargs2._hasOutput()) {
        positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);
      }
      const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares);
      middleware_1.applyMiddleware(innerArgv, yargs2, middlewares, true);
      if (!yargs2._hasOutput()) {
        yargs2._runValidation(innerArgv, aliases, positionalMap, yargs2.parsed.error, !command2);
      }
      if (commandHandler.handler && !yargs2._hasOutput()) {
        yargs2._setHasOutput();
        const populateDoubleDash = !!yargs2.getOptions().configuration["populate--"];
        if (!populateDoubleDash)
          yargs2._copyDoubleDash(innerArgv);
        innerArgv = middleware_1.applyMiddleware(innerArgv, yargs2, middlewares, false);
        let handlerResult;
        if (is_promise_1.isPromise(innerArgv)) {
          handlerResult = innerArgv.then((argv) => commandHandler.handler(argv));
        } else {
          handlerResult = commandHandler.handler(innerArgv);
        }
        const handlerFinishCommand = yargs2.getHandlerFinishCommand();
        if (is_promise_1.isPromise(handlerResult)) {
          yargs2.getUsageInstance().cacheHelpMessage();
          handlerResult.then((value) => {
            if (handlerFinishCommand) {
              handlerFinishCommand(value);
            }
          }).catch((error) => {
            try {
              yargs2.getUsageInstance().fail(null, error);
            } catch (err) {
            }
          }).then(() => {
            yargs2.getUsageInstance().clearCachedHelpMessage();
          });
        } else {
          if (handlerFinishCommand) {
            handlerFinishCommand(handlerResult);
          }
        }
      }
      if (command2) {
        currentContext.commands.pop();
        currentContext.fullCommands.pop();
      }
      numFiles = currentContext.files.length - numFiles;
      if (numFiles > 0)
        currentContext.files.splice(numFiles * -1, numFiles);
      return innerArgv;
    };
    function shouldUpdateUsage(yargs2) {
      return !yargs2.getUsageInstance().getUsageDisabled() && yargs2.getUsageInstance().getUsage().length === 0;
    }
    function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
      const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, "").trim() : commandHandler.original;
      const pc = parentCommands.filter((c2) => {
        return !DEFAULT_MARKER.test(c2);
      });
      pc.push(c);
      return `$0 ${pc.join(" ")}`;
    }
    self.runDefaultBuilderOn = function(yargs2) {
      common_types_1.assertNotStrictEqual(defaultCommand, void 0);
      if (shouldUpdateUsage(yargs2)) {
        const commandString = DEFAULT_MARKER.test(defaultCommand.original) ? defaultCommand.original : defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");
        yargs2.getUsageInstance().usage(commandString, defaultCommand.description);
      }
      const builder = defaultCommand.builder;
      if (isCommandBuilderCallback(builder)) {
        builder(yargs2);
      } else {
        Object.keys(builder).forEach((key) => {
          yargs2.option(key, builder[key]);
        });
      }
    };
    function populatePositionals(commandHandler, argv, context) {
      argv._ = argv._.slice(context.commands.length);
      const demanded = commandHandler.demanded.slice(0);
      const optional = commandHandler.optional.slice(0);
      const positionalMap = {};
      validation.positionalCount(demanded.length, argv._.length);
      while (demanded.length) {
        const demand = demanded.shift();
        populatePositional(demand, argv, positionalMap);
      }
      while (optional.length) {
        const maybe = optional.shift();
        populatePositional(maybe, argv, positionalMap);
      }
      argv._ = context.commands.concat(argv._);
      postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));
      return positionalMap;
    }
    function populatePositional(positional, argv, positionalMap) {
      const cmd = positional.cmd[0];
      if (positional.variadic) {
        positionalMap[cmd] = argv._.splice(0).map(String);
      } else {
        if (argv._.length)
          positionalMap[cmd] = [String(argv._.shift())];
      }
    }
    function postProcessPositionals(argv, positionalMap, parseOptions) {
      const options = Object.assign({}, yargs.getOptions());
      options.default = Object.assign(parseOptions.default, options.default);
      for (const key of Object.keys(parseOptions.alias)) {
        options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
      }
      options.array = options.array.concat(parseOptions.array);
      delete options.config;
      const unparsed = [];
      Object.keys(positionalMap).forEach((key) => {
        positionalMap[key].map((value) => {
          if (options.configuration["unknown-options-as-args"])
            options.key[key] = true;
          unparsed.push(`--${key}`);
          unparsed.push(value);
        });
      });
      if (!unparsed.length)
        return;
      const config = Object.assign({}, options.configuration, {
        "populate--": true
      });
      const parsed = Parser.detailed(unparsed, Object.assign({}, options, {
        configuration: config
      }));
      if (parsed.error) {
        yargs.getUsageInstance().fail(parsed.error.message, parsed.error);
      } else {
        const positionalKeys = Object.keys(positionalMap);
        Object.keys(positionalMap).forEach((key) => {
          positionalKeys.push(...parsed.aliases[key]);
        });
        Object.keys(parsed.argv).forEach((key) => {
          if (positionalKeys.indexOf(key) !== -1) {
            if (!positionalMap[key])
              positionalMap[key] = parsed.argv[key];
            argv[key] = parsed.argv[key];
          }
        });
      }
    }
    self.cmdToParseOptions = function(cmdString) {
      const parseOptions = {
        array: [],
        default: {},
        alias: {},
        demand: {}
      };
      const parsed = parse_command_1.parseCommand(cmdString);
      parsed.demanded.forEach((d) => {
        const [cmd, ...aliases] = d.cmd;
        if (d.variadic) {
          parseOptions.array.push(cmd);
          parseOptions.default[cmd] = [];
        }
        parseOptions.alias[cmd] = aliases;
        parseOptions.demand[cmd] = true;
      });
      parsed.optional.forEach((o) => {
        const [cmd, ...aliases] = o.cmd;
        if (o.variadic) {
          parseOptions.array.push(cmd);
          parseOptions.default[cmd] = [];
        }
        parseOptions.alias[cmd] = aliases;
      });
      return parseOptions;
    };
    self.reset = () => {
      handlers = {};
      aliasMap = {};
      defaultCommand = void 0;
      return self;
    };
    const frozens = [];
    self.freeze = () => {
      frozens.push({
        handlers,
        aliasMap,
        defaultCommand
      });
    };
    self.unfreeze = () => {
      const frozen = frozens.pop();
      common_types_1.assertNotStrictEqual(frozen, void 0);
      ({
        handlers,
        aliasMap,
        defaultCommand
      } = frozen);
    };
    return self;
  }
  exports2.command = command;
  function isCommandHandlerDefinition(cmd) {
    return typeof cmd === "object";
  }
  exports2.isCommandHandlerDefinition = isCommandHandlerDefinition;
  function isCommandBuilderDefinition(builder) {
    return typeof builder === "object" && !!builder.builder && typeof builder.handler === "function";
  }
  exports2.isCommandBuilderDefinition = isCommandBuilderDefinition;
  function isCommandBuilderCallback(builder) {
    return typeof builder === "function";
  }
  exports2.isCommandBuilderCallback = isCommandBuilderCallback;
  function isCommandBuilderOptionDefinitions(builder) {
    return typeof builder === "object";
  }
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/obj-filter.js
var require_obj_filter = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.objFilter = void 0;
  var common_types_1 = require_common_types();
  function objFilter(original = {}, filter = () => true) {
    const obj = {};
    common_types_1.objectKeys(original).forEach((key) => {
      if (filter(key, original[key])) {
        obj[key] = original[key];
      }
    });
    return obj;
  }
  exports2.objFilter = objFilter;
});

// ../../node_modules/.pnpm/set-blocking@2.0.0/node_modules/set-blocking/index.js
var require_set_blocking = __commonJS((exports2, module2) => {
  module2.exports = function(blocking) {
    [process.stdout, process.stderr].forEach(function(stream) {
      if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === "function") {
        stream._handle.setBlocking(blocking);
      }
    });
  };
});

// ../../node_modules/.pnpm/ansi-regex@5.0.0/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = ({onlyFirst = false} = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? void 0 : "g");
  };
});

// ../../node_modules/.pnpm/strip-ansi@6.0.0/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS((exports2, module2) => {
  "use strict";
  var ansiRegex = require_ansi_regex();
  module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
});

// ../../node_modules/.pnpm/is-fullwidth-code-point@3.0.0/node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS((exports2, module2) => {
  "use strict";
  var isFullwidthCodePoint = (codePoint) => {
    if (Number.isNaN(codePoint)) {
      return false;
    }
    if (codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141)) {
      return true;
    }
    return false;
  };
  module2.exports = isFullwidthCodePoint;
  module2.exports.default = isFullwidthCodePoint;
});

// ../../node_modules/.pnpm/emoji-regex@8.0.0/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// ../../node_modules/.pnpm/string-width@4.2.2/node_modules/string-width/index.js
var require_string_width = __commonJS((exports2, module2) => {
  "use strict";
  var stripAnsi = require_strip_ansi();
  var isFullwidthCodePoint = require_is_fullwidth_code_point();
  var emojiRegex = require_emoji_regex();
  var stringWidth = (string) => {
    if (typeof string !== "string" || string.length === 0) {
      return 0;
    }
    string = stripAnsi(string);
    if (string.length === 0) {
      return 0;
    }
    string = string.replace(emojiRegex(), "  ");
    let width = 0;
    for (let i = 0; i < string.length; i++) {
      const code = string.codePointAt(i);
      if (code <= 31 || code >= 127 && code <= 159) {
        continue;
      }
      if (code >= 768 && code <= 879) {
        continue;
      }
      if (code > 65535) {
        i++;
      }
      width += isFullwidthCodePoint(code) ? 2 : 1;
    }
    return width;
  };
  module2.exports = stringWidth;
  module2.exports.default = stringWidth;
});

// ../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports2, module2) => {
  var cssKeywords = require_color_name();
  var reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  var convert = {
    rgb: {channels: 3, labels: "rgb"},
    hsl: {channels: 3, labels: "hsl"},
    hsv: {channels: 3, labels: "hsv"},
    hwb: {channels: 3, labels: "hwb"},
    cmyk: {channels: 4, labels: "cmyk"},
    xyz: {channels: 3, labels: "xyz"},
    lab: {channels: 3, labels: "lab"},
    lch: {channels: 3, labels: "lch"},
    hex: {channels: 1, labels: ["hex"]},
    keyword: {channels: 1, labels: ["keyword"]},
    ansi16: {channels: 1, labels: ["ansi16"]},
    ansi256: {channels: 1, labels: ["ansi256"]},
    hcg: {channels: 3, labels: ["h", "c", "g"]},
    apple: {channels: 3, labels: ["r16", "g16", "b16"]},
    gray: {channels: 1, labels: ["gray"]}
  };
  module2.exports = convert;
  for (const model of Object.keys(convert)) {
    if (!("channels" in convert[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const {channels, labels} = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], "channels", {value: channels});
    Object.defineProperty(convert[model], "labels", {value: labels});
  }
  convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }
  convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
var require_route = __commonJS((exports2, module2) => {
  var conversions = require_conversions();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions);
    for (let len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path2 = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path2.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path2;
    return fn;
  }
  module2.exports = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports2, module2) => {
  var conversions = require_conversions();
  var route = require_route();
  var convert = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
    Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module2.exports = convert;
});

// ../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS((exports2, module2) => {
  "use strict";
  var wrapAnsi16 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `[${code + offset}m`;
  };
  var wrapAnsi256 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `[${38 + offset};5;${code}m`;
  };
  var wrapAnsi16m = (fn, offset) => (...args) => {
    const rgb = fn(...args);
    return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  var ansi2ansi = (n) => n;
  var rgb2rgb = (r, g, b) => [r, g, b];
  var setLazyProperty = (object, property, get) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get();
        Object.defineProperty(object, property, {
          value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
  };
  var colorConvert;
  var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
    if (colorConvert === void 0) {
      colorConvert = require_color_convert();
    }
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
      const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      if (sourceSpace === targetSpace) {
        styles[name] = wrap(identity, offset);
      } else if (typeof suite === "object") {
        styles[name] = wrap(suite[targetSpace], offset);
      }
    }
    return styles;
  };
  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `[${style[0]}m`,
          close: `[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles, "codes", {
      value: codes,
      enumerable: false
    });
    styles.color.close = "[39m";
    styles.bgColor.close = "[49m";
    setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// ../../node_modules/.pnpm/wrap-ansi@6.2.0/node_modules/wrap-ansi/index.js
var require_wrap_ansi = __commonJS((exports2, module2) => {
  "use strict";
  var stringWidth = require_string_width();
  var stripAnsi = require_strip_ansi();
  var ansiStyles = require_ansi_styles();
  var ESCAPES = new Set([
    "",
    "\x9B"
  ]);
  var END_CODE = 39;
  var wrapAnsi = (code) => `${ESCAPES.values().next().value}[${code}m`;
  var wordLengths = (string) => string.split(" ").map((character) => stringWidth(character));
  var wrapWord = (rows, word, columns) => {
    const characters = [...word];
    let isInsideEscape = false;
    let visible = stringWidth(stripAnsi(rows[rows.length - 1]));
    for (const [index, character] of characters.entries()) {
      const characterLength = stringWidth(character);
      if (visible + characterLength <= columns) {
        rows[rows.length - 1] += character;
      } else {
        rows.push(character);
        visible = 0;
      }
      if (ESCAPES.has(character)) {
        isInsideEscape = true;
      } else if (isInsideEscape && character === "m") {
        isInsideEscape = false;
        continue;
      }
      if (isInsideEscape) {
        continue;
      }
      visible += characterLength;
      if (visible === columns && index < characters.length - 1) {
        rows.push("");
        visible = 0;
      }
    }
    if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
      rows[rows.length - 2] += rows.pop();
    }
  };
  var stringVisibleTrimSpacesRight = (str) => {
    const words = str.split(" ");
    let last = words.length;
    while (last > 0) {
      if (stringWidth(words[last - 1]) > 0) {
        break;
      }
      last--;
    }
    if (last === words.length) {
      return str;
    }
    return words.slice(0, last).join(" ") + words.slice(last).join("");
  };
  var exec = (string, columns, options = {}) => {
    if (options.trim !== false && string.trim() === "") {
      return "";
    }
    let pre = "";
    let ret = "";
    let escapeCode;
    const lengths = wordLengths(string);
    let rows = [""];
    for (const [index, word] of string.split(" ").entries()) {
      if (options.trim !== false) {
        rows[rows.length - 1] = rows[rows.length - 1].trimLeft();
      }
      let rowLength = stringWidth(rows[rows.length - 1]);
      if (index !== 0) {
        if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
          rows.push("");
          rowLength = 0;
        }
        if (rowLength > 0 || options.trim === false) {
          rows[rows.length - 1] += " ";
          rowLength++;
        }
      }
      if (options.hard && lengths[index] > columns) {
        const remainingColumns = columns - rowLength;
        const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
        const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
        if (breaksStartingNextLine < breaksStartingThisLine) {
          rows.push("");
        }
        wrapWord(rows, word, columns);
        continue;
      }
      if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
        if (options.wordWrap === false && rowLength < columns) {
          wrapWord(rows, word, columns);
          continue;
        }
        rows.push("");
      }
      if (rowLength + lengths[index] > columns && options.wordWrap === false) {
        wrapWord(rows, word, columns);
        continue;
      }
      rows[rows.length - 1] += word;
    }
    if (options.trim !== false) {
      rows = rows.map(stringVisibleTrimSpacesRight);
    }
    pre = rows.join("\n");
    for (const [index, character] of [...pre].entries()) {
      ret += character;
      if (ESCAPES.has(character)) {
        const code2 = parseFloat(/\d[^m]*/.exec(pre.slice(index, index + 4)));
        escapeCode = code2 === END_CODE ? null : code2;
      }
      const code = ansiStyles.codes.get(Number(escapeCode));
      if (escapeCode && code) {
        if (pre[index + 1] === "\n") {
          ret += wrapAnsi(code);
        } else if (character === "\n") {
          ret += wrapAnsi(escapeCode);
        }
      }
    }
    return ret;
  };
  module2.exports = (string, columns, options) => {
    return String(string).normalize().replace(/\r\n/g, "\n").split("\n").map((line) => exec(line, columns, options)).join("\n");
  };
});

// ../../node_modules/.pnpm/cliui@6.0.0/node_modules/cliui/index.js
var require_cliui = __commonJS((exports2, module2) => {
  "use strict";
  var stringWidth = require_string_width();
  var stripAnsi = require_strip_ansi();
  var wrap = require_wrap_ansi();
  var align = {
    right: alignRight,
    center: alignCenter
  };
  var top = 0;
  var right = 1;
  var bottom = 2;
  var left = 3;
  var UI = class {
    constructor(opts) {
      this.width = opts.width;
      this.wrap = opts.wrap;
      this.rows = [];
    }
    span(...args) {
      const cols = this.div(...args);
      cols.span = true;
    }
    resetOutput() {
      this.rows = [];
    }
    div(...args) {
      if (args.length === 0) {
        this.div("");
      }
      if (this.wrap && this._shouldApplyLayoutDSL(...args)) {
        return this._applyLayoutDSL(args[0]);
      }
      const cols = args.map((arg) => {
        if (typeof arg === "string") {
          return this._colFromString(arg);
        }
        return arg;
      });
      this.rows.push(cols);
      return cols;
    }
    _shouldApplyLayoutDSL(...args) {
      return args.length === 1 && typeof args[0] === "string" && /[\t\n]/.test(args[0]);
    }
    _applyLayoutDSL(str) {
      const rows = str.split("\n").map((row) => row.split("	"));
      let leftColumnWidth = 0;
      rows.forEach((columns) => {
        if (columns.length > 1 && stringWidth(columns[0]) > leftColumnWidth) {
          leftColumnWidth = Math.min(Math.floor(this.width * 0.5), stringWidth(columns[0]));
        }
      });
      rows.forEach((columns) => {
        this.div(...columns.map((r, i) => {
          return {
            text: r.trim(),
            padding: this._measurePadding(r),
            width: i === 0 && columns.length > 1 ? leftColumnWidth : void 0
          };
        }));
      });
      return this.rows[this.rows.length - 1];
    }
    _colFromString(text) {
      return {
        text,
        padding: this._measurePadding(text)
      };
    }
    _measurePadding(str) {
      const noAnsi = stripAnsi(str);
      return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
    }
    toString() {
      const lines = [];
      this.rows.forEach((row) => {
        this.rowToString(row, lines);
      });
      return lines.filter((line) => !line.hidden).map((line) => line.text).join("\n");
    }
    rowToString(row, lines) {
      this._rasterize(row).forEach((rrow, r) => {
        let str = "";
        rrow.forEach((col, c) => {
          const {width} = row[c];
          const wrapWidth = this._negatePadding(row[c]);
          let ts = col;
          if (wrapWidth > stringWidth(col)) {
            ts += " ".repeat(wrapWidth - stringWidth(col));
          }
          if (row[c].align && row[c].align !== "left" && this.wrap) {
            ts = align[row[c].align](ts, wrapWidth);
            if (stringWidth(ts) < wrapWidth) {
              ts += " ".repeat(width - stringWidth(ts) - 1);
            }
          }
          const padding = row[c].padding || [0, 0, 0, 0];
          if (padding[left]) {
            str += " ".repeat(padding[left]);
          }
          str += addBorder(row[c], ts, "| ");
          str += ts;
          str += addBorder(row[c], ts, " |");
          if (padding[right]) {
            str += " ".repeat(padding[right]);
          }
          if (r === 0 && lines.length > 0) {
            str = this._renderInline(str, lines[lines.length - 1]);
          }
        });
        lines.push({
          text: str.replace(/ +$/, ""),
          span: row.span
        });
      });
      return lines;
    }
    _renderInline(source, previousLine) {
      const leadingWhitespace = source.match(/^ */)[0].length;
      const target = previousLine.text;
      const targetTextWidth = stringWidth(target.trimRight());
      if (!previousLine.span) {
        return source;
      }
      if (!this.wrap) {
        previousLine.hidden = true;
        return target + source;
      }
      if (leadingWhitespace < targetTextWidth) {
        return source;
      }
      previousLine.hidden = true;
      return target.trimRight() + " ".repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
    }
    _rasterize(row) {
      const rrows = [];
      const widths = this._columnWidths(row);
      let wrapped;
      row.forEach((col, c) => {
        col.width = widths[c];
        if (this.wrap) {
          wrapped = wrap(col.text, this._negatePadding(col), {hard: true}).split("\n");
        } else {
          wrapped = col.text.split("\n");
        }
        if (col.border) {
          wrapped.unshift("." + "-".repeat(this._negatePadding(col) + 2) + ".");
          wrapped.push("'" + "-".repeat(this._negatePadding(col) + 2) + "'");
        }
        if (col.padding) {
          wrapped.unshift(...new Array(col.padding[top] || 0).fill(""));
          wrapped.push(...new Array(col.padding[bottom] || 0).fill(""));
        }
        wrapped.forEach((str, r) => {
          if (!rrows[r]) {
            rrows.push([]);
          }
          const rrow = rrows[r];
          for (let i = 0; i < c; i++) {
            if (rrow[i] === void 0) {
              rrow.push("");
            }
          }
          rrow.push(str);
        });
      });
      return rrows;
    }
    _negatePadding(col) {
      let wrapWidth = col.width;
      if (col.padding) {
        wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
      }
      if (col.border) {
        wrapWidth -= 4;
      }
      return wrapWidth;
    }
    _columnWidths(row) {
      if (!this.wrap) {
        return row.map((col) => {
          return col.width || stringWidth(col.text);
        });
      }
      let unset = row.length;
      let remainingWidth = this.width;
      const widths = row.map((col) => {
        if (col.width) {
          unset--;
          remainingWidth -= col.width;
          return col.width;
        }
        return void 0;
      });
      const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
      return widths.map((w, i) => {
        if (w === void 0) {
          return Math.max(unsetWidth, _minWidth(row[i]));
        }
        return w;
      });
    }
  };
  function addBorder(col, ts, style) {
    if (col.border) {
      if (/[.']-+[.']/.test(ts)) {
        return "";
      }
      if (ts.trim().length !== 0) {
        return style;
      }
      return "  ";
    }
    return "";
  }
  function _minWidth(col) {
    const padding = col.padding || [];
    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
    if (col.border) {
      return minWidth + 4;
    }
    return minWidth;
  }
  function getWindowWidth() {
    if (typeof process === "object" && process.stdout && process.stdout.columns) {
      return process.stdout.columns;
    }
  }
  function alignRight(str, width) {
    str = str.trim();
    const strWidth = stringWidth(str);
    if (strWidth < width) {
      return " ".repeat(width - strWidth) + str;
    }
    return str;
  }
  function alignCenter(str, width) {
    str = str.trim();
    const strWidth = stringWidth(str);
    if (strWidth >= width) {
      return str;
    }
    return " ".repeat(width - strWidth >> 1) + str;
  }
  module2.exports = function(opts = {}) {
    return new UI({
      width: opts.width || getWindowWidth() || 80,
      wrap: opts.wrap !== false
    });
  };
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/usage.js
var require_usage = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.usage = void 0;
  var common_types_1 = require_common_types();
  var obj_filter_1 = require_obj_filter();
  var path2 = require("path");
  var yerror_1 = require_yerror();
  var decamelize = require_decamelize();
  var setBlocking = require_set_blocking();
  var stringWidth = require_string_width();
  function usage(yargs, y18n) {
    const __ = y18n.__;
    const self = {};
    const fails = [];
    self.failFn = function failFn(f) {
      fails.push(f);
    };
    let failMessage = null;
    let showHelpOnFail = true;
    self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {
      function parseFunctionArgs() {
        return typeof arg1 === "string" ? [true, arg1] : [arg1, arg2];
      }
      const [enabled, message] = parseFunctionArgs();
      failMessage = message;
      showHelpOnFail = enabled;
      return self;
    };
    let failureOutput = false;
    self.fail = function fail(msg, err) {
      const logger = yargs._getLoggerInstance();
      if (fails.length) {
        for (let i = fails.length - 1; i >= 0; --i) {
          fails[i](msg, err, self);
        }
      } else {
        if (yargs.getExitProcess())
          setBlocking(true);
        if (!failureOutput) {
          failureOutput = true;
          if (showHelpOnFail) {
            yargs.showHelp("error");
            logger.error();
          }
          if (msg || err)
            logger.error(msg || err);
          if (failMessage) {
            if (msg || err)
              logger.error("");
            logger.error(failMessage);
          }
        }
        err = err || new yerror_1.YError(msg);
        if (yargs.getExitProcess()) {
          return yargs.exit(1);
        } else if (yargs._hasParseCallback()) {
          return yargs.exit(1, err);
        } else {
          throw err;
        }
      }
    };
    let usages = [];
    let usageDisabled = false;
    self.usage = (msg, description) => {
      if (msg === null) {
        usageDisabled = true;
        usages = [];
        return self;
      }
      usageDisabled = false;
      usages.push([msg, description || ""]);
      return self;
    };
    self.getUsage = () => {
      return usages;
    };
    self.getUsageDisabled = () => {
      return usageDisabled;
    };
    self.getPositionalGroupName = () => {
      return __("Positionals:");
    };
    let examples = [];
    self.example = (cmd, description) => {
      examples.push([cmd, description || ""]);
    };
    let commands = [];
    self.command = function command(cmd, description, isDefault, aliases, deprecated = false) {
      if (isDefault) {
        commands = commands.map((cmdArray) => {
          cmdArray[2] = false;
          return cmdArray;
        });
      }
      commands.push([cmd, description || "", isDefault, aliases, deprecated]);
    };
    self.getCommands = () => commands;
    let descriptions = {};
    self.describe = function describe(keyOrKeys, desc) {
      if (Array.isArray(keyOrKeys)) {
        keyOrKeys.forEach((k) => {
          self.describe(k, desc);
        });
      } else if (typeof keyOrKeys === "object") {
        Object.keys(keyOrKeys).forEach((k) => {
          self.describe(k, keyOrKeys[k]);
        });
      } else {
        descriptions[keyOrKeys] = desc;
      }
    };
    self.getDescriptions = () => descriptions;
    let epilogs = [];
    self.epilog = (msg) => {
      epilogs.push(msg);
    };
    let wrapSet = false;
    let wrap;
    self.wrap = (cols) => {
      wrapSet = true;
      wrap = cols;
    };
    function getWrap() {
      if (!wrapSet) {
        wrap = windowWidth();
        wrapSet = true;
      }
      return wrap;
    }
    const deferY18nLookupPrefix = "__yargsString__:";
    self.deferY18nLookup = (str) => deferY18nLookupPrefix + str;
    self.help = function help() {
      if (cachedHelpMessage)
        return cachedHelpMessage;
      normalizeAliases();
      const base$0 = yargs.customScriptName ? yargs.$0 : path2.basename(yargs.$0);
      const demandedOptions = yargs.getDemandedOptions();
      const demandedCommands = yargs.getDemandedCommands();
      const deprecatedOptions = yargs.getDeprecatedOptions();
      const groups = yargs.getGroups();
      const options = yargs.getOptions();
      let keys = [];
      keys = keys.concat(Object.keys(descriptions));
      keys = keys.concat(Object.keys(demandedOptions));
      keys = keys.concat(Object.keys(demandedCommands));
      keys = keys.concat(Object.keys(options.default));
      keys = keys.filter(filterHiddenOptions);
      keys = Object.keys(keys.reduce((acc, key) => {
        if (key !== "_")
          acc[key] = true;
        return acc;
      }, {}));
      const theWrap = getWrap();
      const ui = require_cliui()({
        width: theWrap,
        wrap: !!theWrap
      });
      if (!usageDisabled) {
        if (usages.length) {
          usages.forEach((usage2) => {
            ui.div(`${usage2[0].replace(/\$0/g, base$0)}`);
            if (usage2[1]) {
              ui.div({text: `${usage2[1]}`, padding: [1, 0, 0, 0]});
            }
          });
          ui.div();
        } else if (commands.length) {
          let u = null;
          if (demandedCommands._) {
            u = `${base$0} <${__("command")}>
`;
          } else {
            u = `${base$0} [${__("command")}]
`;
          }
          ui.div(`${u}`);
        }
      }
      if (commands.length) {
        ui.div(__("Commands:"));
        const context = yargs.getContext();
        const parentCommands = context.commands.length ? `${context.commands.join(" ")} ` : "";
        if (yargs.getParserConfiguration()["sort-commands"] === true) {
          commands = commands.sort((a, b) => a[0].localeCompare(b[0]));
        }
        commands.forEach((command) => {
          const commandString = `${base$0} ${parentCommands}${command[0].replace(/^\$0 ?/, "")}`;
          ui.span({
            text: commandString,
            padding: [0, 2, 0, 2],
            width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4
          }, {text: command[1]});
          const hints = [];
          if (command[2])
            hints.push(`[${__("default")}]`);
          if (command[3] && command[3].length) {
            hints.push(`[${__("aliases:")} ${command[3].join(", ")}]`);
          }
          if (command[4]) {
            if (typeof command[4] === "string") {
              hints.push(`[${__("deprecated: %s", command[4])}]`);
            } else {
              hints.push(`[${__("deprecated")}]`);
            }
          }
          if (hints.length) {
            ui.div({text: hints.join(" "), padding: [0, 0, 0, 2], align: "right"});
          } else {
            ui.div();
          }
        });
        ui.div();
      }
      const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
      keys = keys.filter((key) => !yargs.parsed.newAliases[key] && aliasKeys.every((alias) => (options.alias[alias] || []).indexOf(key) === -1));
      const defaultGroup = __("Options:");
      if (!groups[defaultGroup])
        groups[defaultGroup] = [];
      addUngroupedKeys(keys, options.alias, groups, defaultGroup);
      Object.keys(groups).forEach((groupName) => {
        if (!groups[groupName].length)
          return;
        const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) => {
          if (~aliasKeys.indexOf(key))
            return key;
          for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== void 0; i++) {
            if (~(options.alias[aliasKey] || []).indexOf(key))
              return aliasKey;
          }
          return key;
        });
        if (normalizedKeys.length < 1)
          return;
        ui.div(groupName);
        const switches = normalizedKeys.reduce((acc, key) => {
          acc[key] = [key].concat(options.alias[key] || []).map((sw) => {
            if (groupName === self.getPositionalGroupName())
              return sw;
            else {
              return (/^[0-9]$/.test(sw) ? ~options.boolean.indexOf(key) ? "-" : "--" : sw.length > 1 ? "--" : "-") + sw;
            }
          }).join(", ");
          return acc;
        }, {});
        normalizedKeys.forEach((key) => {
          const kswitch = switches[key];
          let desc = descriptions[key] || "";
          let type = null;
          if (~desc.lastIndexOf(deferY18nLookupPrefix))
            desc = __(desc.substring(deferY18nLookupPrefix.length));
          if (~options.boolean.indexOf(key))
            type = `[${__("boolean")}]`;
          if (~options.count.indexOf(key))
            type = `[${__("count")}]`;
          if (~options.string.indexOf(key))
            type = `[${__("string")}]`;
          if (~options.normalize.indexOf(key))
            type = `[${__("string")}]`;
          if (~options.array.indexOf(key))
            type = `[${__("array")}]`;
          if (~options.number.indexOf(key))
            type = `[${__("number")}]`;
          const deprecatedExtra = (deprecated) => typeof deprecated === "string" ? `[${__("deprecated: %s", deprecated)}]` : `[${__("deprecated")}]`;
          const extra = [
            key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null,
            type,
            key in demandedOptions ? `[${__("required")}]` : null,
            options.choices && options.choices[key] ? `[${__("choices:")} ${self.stringifiedValues(options.choices[key])}]` : null,
            defaultString(options.default[key], options.defaultDescription[key])
          ].filter(Boolean).join(" ");
          ui.span({text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches, theWrap) + 4}, desc);
          if (extra)
            ui.div({text: extra, padding: [0, 0, 0, 2], align: "right"});
          else
            ui.div();
        });
        ui.div();
      });
      if (examples.length) {
        ui.div(__("Examples:"));
        examples.forEach((example) => {
          example[0] = example[0].replace(/\$0/g, base$0);
        });
        examples.forEach((example) => {
          if (example[1] === "") {
            ui.div({
              text: example[0],
              padding: [0, 2, 0, 2]
            });
          } else {
            ui.div({
              text: example[0],
              padding: [0, 2, 0, 2],
              width: maxWidth(examples, theWrap) + 4
            }, {
              text: example[1]
            });
          }
        });
        ui.div();
      }
      if (epilogs.length > 0) {
        const e = epilogs.map((epilog) => epilog.replace(/\$0/g, base$0)).join("\n");
        ui.div(`${e}
`);
      }
      return ui.toString().replace(/\s*$/, "");
    };
    function maxWidth(table, theWrap, modifier) {
      let width = 0;
      if (!Array.isArray(table)) {
        table = Object.values(table).map((v) => [v]);
      }
      table.forEach((v) => {
        width = Math.max(stringWidth(modifier ? `${modifier} ${v[0]}` : v[0]), width);
      });
      if (theWrap)
        width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
      return width;
    }
    function normalizeAliases() {
      const demandedOptions = yargs.getDemandedOptions();
      const options = yargs.getOptions();
      (Object.keys(options.alias) || []).forEach((key) => {
        options.alias[key].forEach((alias) => {
          if (descriptions[alias])
            self.describe(key, descriptions[alias]);
          if (alias in demandedOptions)
            yargs.demandOption(key, demandedOptions[alias]);
          if (~options.boolean.indexOf(alias))
            yargs.boolean(key);
          if (~options.count.indexOf(alias))
            yargs.count(key);
          if (~options.string.indexOf(alias))
            yargs.string(key);
          if (~options.normalize.indexOf(alias))
            yargs.normalize(key);
          if (~options.array.indexOf(alias))
            yargs.array(key);
          if (~options.number.indexOf(alias))
            yargs.number(key);
        });
      });
    }
    let cachedHelpMessage;
    self.cacheHelpMessage = function() {
      cachedHelpMessage = this.help();
    };
    self.clearCachedHelpMessage = function() {
      cachedHelpMessage = void 0;
    };
    function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
      let groupedKeys = [];
      let toCheck = null;
      Object.keys(groups).forEach((group) => {
        groupedKeys = groupedKeys.concat(groups[group]);
      });
      keys.forEach((key) => {
        toCheck = [key].concat(aliases[key]);
        if (!toCheck.some((k) => groupedKeys.indexOf(k) !== -1)) {
          groups[defaultGroup].push(key);
        }
      });
      return groupedKeys;
    }
    function filterHiddenOptions(key) {
      return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];
    }
    self.showHelp = (level) => {
      const logger = yargs._getLoggerInstance();
      if (!level)
        level = "error";
      const emit = typeof level === "function" ? level : logger[level];
      emit(self.help());
    };
    self.functionDescription = (fn) => {
      const description = fn.name ? decamelize(fn.name, "-") : __("generated-value");
      return ["(", description, ")"].join("");
    };
    self.stringifiedValues = function stringifiedValues(values, separator) {
      let string = "";
      const sep = separator || ", ";
      const array = [].concat(values);
      if (!values || !array.length)
        return string;
      array.forEach((value) => {
        if (string.length)
          string += sep;
        string += JSON.stringify(value);
      });
      return string;
    };
    function defaultString(value, defaultDescription) {
      let string = `[${__("default:")} `;
      if (value === void 0 && !defaultDescription)
        return null;
      if (defaultDescription) {
        string += defaultDescription;
      } else {
        switch (typeof value) {
          case "string":
            string += `"${value}"`;
            break;
          case "object":
            string += JSON.stringify(value);
            break;
          default:
            string += value;
        }
      }
      return `${string}]`;
    }
    function windowWidth() {
      const maxWidth2 = 80;
      if (typeof process === "object" && process.stdout && process.stdout.columns) {
        return Math.min(maxWidth2, process.stdout.columns);
      } else {
        return maxWidth2;
      }
    }
    let version = null;
    self.version = (ver) => {
      version = ver;
    };
    self.showVersion = () => {
      const logger = yargs._getLoggerInstance();
      logger.log(version);
    };
    self.reset = function reset(localLookup) {
      failMessage = null;
      failureOutput = false;
      usages = [];
      usageDisabled = false;
      epilogs = [];
      examples = [];
      commands = [];
      descriptions = obj_filter_1.objFilter(descriptions, (k) => !localLookup[k]);
      return self;
    };
    const frozens = [];
    self.freeze = function freeze() {
      frozens.push({
        failMessage,
        failureOutput,
        usages,
        usageDisabled,
        epilogs,
        examples,
        commands,
        descriptions
      });
    };
    self.unfreeze = function unfreeze() {
      const frozen = frozens.pop();
      common_types_1.assertNotStrictEqual(frozen, void 0);
      ({
        failMessage,
        failureOutput,
        usages,
        usageDisabled,
        epilogs,
        examples,
        commands,
        descriptions
      } = frozen);
    };
    return self;
  }
  exports2.usage = usage;
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/completion-templates.js
var require_completion_templates = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.completionZshTemplate = exports2.completionShTemplate = void 0;
  exports2.completionShTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o default -F _yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
  exports2.completionZshTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/completion.js
var require_completion = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.completion = void 0;
  var command_1 = require_command();
  var templates = require_completion_templates();
  var is_promise_1 = require_is_promise();
  var parse_command_1 = require_parse_command();
  var path2 = require("path");
  var common_types_1 = require_common_types();
  function completion(yargs, usage, command) {
    const self = {
      completionKey: "get-yargs-completions"
    };
    let aliases;
    self.setParsed = function setParsed(parsed) {
      aliases = parsed.aliases;
    };
    const zshShell = process.env.SHELL && process.env.SHELL.indexOf("zsh") !== -1 || process.env.ZSH_NAME && process.env.ZSH_NAME.indexOf("zsh") !== -1;
    self.getCompletion = function getCompletion(args, done) {
      const completions = [];
      const current = args.length ? args[args.length - 1] : "";
      const argv = yargs.parse(args, true);
      const parentCommands = yargs.getContext().commands;
      function runCompletionFunction(argv2) {
        common_types_1.assertNotStrictEqual(completionFunction, null);
        if (isSyncCompletionFunction(completionFunction)) {
          const result = completionFunction(current, argv2);
          if (is_promise_1.isPromise(result)) {
            return result.then((list) => {
              process.nextTick(() => {
                done(list);
              });
            }).catch((err) => {
              process.nextTick(() => {
                throw err;
              });
            });
          }
          return done(result);
        } else {
          return completionFunction(current, argv2, (completions2) => {
            done(completions2);
          });
        }
      }
      if (completionFunction) {
        return is_promise_1.isPromise(argv) ? argv.then(runCompletionFunction) : runCompletionFunction(argv);
      }
      const handlers = command.getCommandHandlers();
      for (let i = 0, ii = args.length; i < ii; ++i) {
        if (handlers[args[i]] && handlers[args[i]].builder) {
          const builder = handlers[args[i]].builder;
          if (command_1.isCommandBuilderCallback(builder)) {
            const y = yargs.reset();
            builder(y);
            return y.argv;
          }
        }
      }
      if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current) {
        usage.getCommands().forEach((usageCommand) => {
          const commandName = parse_command_1.parseCommand(usageCommand[0]).cmd;
          if (args.indexOf(commandName) === -1) {
            if (!zshShell) {
              completions.push(commandName);
            } else {
              const desc = usageCommand[1] || "";
              completions.push(commandName.replace(/:/g, "\\:") + ":" + desc);
            }
          }
        });
      }
      if (current.match(/^-/) || current === "" && completions.length === 0) {
        const descs = usage.getDescriptions();
        const options = yargs.getOptions();
        Object.keys(options.key).forEach((key) => {
          const negable = !!options.configuration["boolean-negation"] && options.boolean.includes(key);
          let keyAndAliases = [key].concat(aliases[key] || []);
          if (negable)
            keyAndAliases = keyAndAliases.concat(keyAndAliases.map((key2) => `no-${key2}`));
          function completeOptionKey(key2) {
            const notInArgs = keyAndAliases.every((val) => args.indexOf(`--${val}`) === -1);
            if (notInArgs) {
              const startsByTwoDashes = (s) => /^--/.test(s);
              const isShortOption = (s) => /^[^0-9]$/.test(s);
              const dashes = !startsByTwoDashes(current) && isShortOption(key2) ? "-" : "--";
              if (!zshShell) {
                completions.push(dashes + key2);
              } else {
                const desc = descs[key2] || "";
                completions.push(dashes + `${key2.replace(/:/g, "\\:")}:${desc.replace("__yargsString__:", "")}`);
              }
            }
          }
          completeOptionKey(key);
          if (negable && !!options.default[key])
            completeOptionKey(`no-${key}`);
        });
      }
      done(completions);
    };
    self.generateCompletionScript = function generateCompletionScript($0, cmd) {
      let script = zshShell ? templates.completionZshTemplate : templates.completionShTemplate;
      const name = path2.basename($0);
      if ($0.match(/\.js$/))
        $0 = `./${$0}`;
      script = script.replace(/{{app_name}}/g, name);
      script = script.replace(/{{completion_command}}/g, cmd);
      return script.replace(/{{app_path}}/g, $0);
    };
    let completionFunction = null;
    self.registerFunction = (fn) => {
      completionFunction = fn;
    };
    return self;
  }
  exports2.completion = completion;
  function isSyncCompletionFunction(completionFunction) {
    return completionFunction.length < 3;
  }
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/levenshtein.js
var require_levenshtein = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.levenshtein = void 0;
  function levenshtein(a, b) {
    if (a.length === 0)
      return b.length;
    if (b.length === 0)
      return a.length;
    const matrix = [];
    let i;
    for (i = 0; i <= b.length; i++) {
      matrix[i] = [i];
    }
    let j;
    for (j = 0; j <= a.length; j++) {
      matrix[0][j] = j;
    }
    for (i = 1; i <= b.length; i++) {
      for (j = 1; j <= a.length; j++) {
        if (b.charAt(i - 1) === a.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
        }
      }
    }
    return matrix[b.length][a.length];
  }
  exports2.levenshtein = levenshtein;
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/validation.js
var require_validation = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.validation = void 0;
  var argsert_1 = require_argsert();
  var common_types_1 = require_common_types();
  var levenshtein_1 = require_levenshtein();
  var obj_filter_1 = require_obj_filter();
  var specialKeys = ["$0", "--", "_"];
  function validation(yargs, usage, y18n) {
    const __ = y18n.__;
    const __n = y18n.__n;
    const self = {};
    self.nonOptionCount = function nonOptionCount(argv) {
      const demandedCommands = yargs.getDemandedCommands();
      const _s = argv._.length - yargs.getContext().commands.length;
      if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
        if (_s < demandedCommands._.min) {
          if (demandedCommands._.minMsg !== void 0) {
            usage.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString()) : null);
          } else {
            usage.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", _s, _s, demandedCommands._.min));
          }
        } else if (_s > demandedCommands._.max) {
          if (demandedCommands._.maxMsg !== void 0) {
            usage.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString()) : null);
          } else {
            usage.fail(__n("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", _s, _s, demandedCommands._.max));
          }
        }
      }
    };
    self.positionalCount = function positionalCount(required, observed) {
      if (observed < required) {
        usage.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", observed, observed, required));
      }
    };
    self.requiredArguments = function requiredArguments(argv) {
      const demandedOptions = yargs.getDemandedOptions();
      let missing = null;
      for (const key of Object.keys(demandedOptions)) {
        if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === "undefined") {
          missing = missing || {};
          missing[key] = demandedOptions[key];
        }
      }
      if (missing) {
        const customMsgs = [];
        for (const key of Object.keys(missing)) {
          const msg = missing[key];
          if (msg && customMsgs.indexOf(msg) < 0) {
            customMsgs.push(msg);
          }
        }
        const customMsg = customMsgs.length ? `
${customMsgs.join("\n")}` : "";
        usage.fail(__n("Missing required argument: %s", "Missing required arguments: %s", Object.keys(missing).length, Object.keys(missing).join(", ") + customMsg));
      }
    };
    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand) {
      const commandKeys = yargs.getCommandInstance().getCommands();
      const unknown = [];
      const currentContext = yargs.getContext();
      Object.keys(argv).forEach((key) => {
        if (specialKeys.indexOf(key) === -1 && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {
          unknown.push(key);
        }
      });
      if (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand) {
        argv._.slice(currentContext.commands.length).forEach((key) => {
          if (commandKeys.indexOf(key) === -1) {
            unknown.push(key);
          }
        });
      }
      if (unknown.length > 0) {
        usage.fail(__n("Unknown argument: %s", "Unknown arguments: %s", unknown.length, unknown.join(", ")));
      }
    };
    self.unknownCommands = function unknownCommands(argv) {
      const commandKeys = yargs.getCommandInstance().getCommands();
      const unknown = [];
      const currentContext = yargs.getContext();
      if (currentContext.commands.length > 0 || commandKeys.length > 0) {
        argv._.slice(currentContext.commands.length).forEach((key) => {
          if (commandKeys.indexOf(key) === -1) {
            unknown.push(key);
          }
        });
      }
      if (unknown.length > 0) {
        usage.fail(__n("Unknown command: %s", "Unknown commands: %s", unknown.length, unknown.join(", ")));
        return true;
      } else {
        return false;
      }
    };
    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
      if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
        return false;
      }
      const newAliases = yargs.parsed.newAliases;
      for (const a of [key, ...aliases[key]]) {
        if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {
          return true;
        }
      }
      return false;
    };
    self.limitedChoices = function limitedChoices(argv) {
      const options = yargs.getOptions();
      const invalid = {};
      if (!Object.keys(options.choices).length)
        return;
      Object.keys(argv).forEach((key) => {
        if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {
          [].concat(argv[key]).forEach((value) => {
            if (options.choices[key].indexOf(value) === -1 && value !== void 0) {
              invalid[key] = (invalid[key] || []).concat(value);
            }
          });
        }
      });
      const invalidKeys = Object.keys(invalid);
      if (!invalidKeys.length)
        return;
      let msg = __("Invalid values:");
      invalidKeys.forEach((key) => {
        msg += `
  ${__("Argument: %s, Given: %s, Choices: %s", key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;
      });
      usage.fail(msg);
    };
    let checks = [];
    self.check = function check(f, global2) {
      checks.push({
        func: f,
        global: global2
      });
    };
    self.customChecks = function customChecks(argv, aliases) {
      for (let i = 0, f; (f = checks[i]) !== void 0; i++) {
        const func = f.func;
        let result = null;
        try {
          result = func(argv, aliases);
        } catch (err) {
          usage.fail(err.message ? err.message : err, err);
          continue;
        }
        if (!result) {
          usage.fail(__("Argument check failed: %s", func.toString()));
        } else if (typeof result === "string" || result instanceof Error) {
          usage.fail(result.toString(), result);
        }
      }
    };
    let implied = {};
    self.implies = function implies(key, value) {
      argsert_1.argsert("<string|object> [array|number|string]", [key, value], arguments.length);
      if (typeof key === "object") {
        Object.keys(key).forEach((k) => {
          self.implies(k, key[k]);
        });
      } else {
        yargs.global(key);
        if (!implied[key]) {
          implied[key] = [];
        }
        if (Array.isArray(value)) {
          value.forEach((i) => self.implies(key, i));
        } else {
          common_types_1.assertNotStrictEqual(value, void 0);
          implied[key].push(value);
        }
      }
    };
    self.getImplied = function getImplied() {
      return implied;
    };
    function keyExists(argv, val) {
      const num = Number(val);
      val = isNaN(num) ? val : num;
      if (typeof val === "number") {
        val = argv._.length >= val;
      } else if (val.match(/^--no-.+/)) {
        val = val.match(/^--no-(.+)/)[1];
        val = !argv[val];
      } else {
        val = argv[val];
      }
      return val;
    }
    self.implications = function implications(argv) {
      const implyFail = [];
      Object.keys(implied).forEach((key) => {
        const origKey = key;
        (implied[key] || []).forEach((value) => {
          let key2 = origKey;
          const origValue = value;
          key2 = keyExists(argv, key2);
          value = keyExists(argv, value);
          if (key2 && !value) {
            implyFail.push(` ${origKey} -> ${origValue}`);
          }
        });
      });
      if (implyFail.length) {
        let msg = `${__("Implications failed:")}
`;
        implyFail.forEach((value) => {
          msg += value;
        });
        usage.fail(msg);
      }
    };
    let conflicting = {};
    self.conflicts = function conflicts(key, value) {
      argsert_1.argsert("<string|object> [array|string]", [key, value], arguments.length);
      if (typeof key === "object") {
        Object.keys(key).forEach((k) => {
          self.conflicts(k, key[k]);
        });
      } else {
        yargs.global(key);
        if (!conflicting[key]) {
          conflicting[key] = [];
        }
        if (Array.isArray(value)) {
          value.forEach((i) => self.conflicts(key, i));
        } else {
          conflicting[key].push(value);
        }
      }
    };
    self.getConflicting = () => conflicting;
    self.conflicting = function conflictingFn(argv) {
      Object.keys(argv).forEach((key) => {
        if (conflicting[key]) {
          conflicting[key].forEach((value) => {
            if (value && argv[key] !== void 0 && argv[value] !== void 0) {
              usage.fail(__("Arguments %s and %s are mutually exclusive", key, value));
            }
          });
        }
      });
    };
    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {
      const threshold = 3;
      potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);
      let recommended = null;
      let bestDistance = Infinity;
      for (let i = 0, candidate; (candidate = potentialCommands[i]) !== void 0; i++) {
        const d = levenshtein_1.levenshtein(cmd, candidate);
        if (d <= threshold && d < bestDistance) {
          bestDistance = d;
          recommended = candidate;
        }
      }
      if (recommended)
        usage.fail(__("Did you mean %s?", recommended));
    };
    self.reset = function reset(localLookup) {
      implied = obj_filter_1.objFilter(implied, (k) => !localLookup[k]);
      conflicting = obj_filter_1.objFilter(conflicting, (k) => !localLookup[k]);
      checks = checks.filter((c) => c.global);
      return self;
    };
    const frozens = [];
    self.freeze = function freeze() {
      frozens.push({
        implied,
        checks,
        conflicting
      });
    };
    self.unfreeze = function unfreeze() {
      const frozen = frozens.pop();
      common_types_1.assertNotStrictEqual(frozen, void 0);
      ({
        implied,
        checks,
        conflicting
      } = frozen);
    };
    return self;
  }
  exports2.validation = validation;
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/apply-extends.js
var require_apply_extends = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.applyExtends = void 0;
  var fs = require("fs");
  var path2 = require("path");
  var yerror_1 = require_yerror();
  var previouslyVisitedConfigs = [];
  function checkForCircularExtends(cfgPath) {
    if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
      throw new yerror_1.YError(`Circular extended configurations: '${cfgPath}'.`);
    }
  }
  function getPathToDefaultConfig(cwd, pathToExtend) {
    return path2.resolve(cwd, pathToExtend);
  }
  function mergeDeep(config1, config2) {
    const target = {};
    function isObject(obj) {
      return obj && typeof obj === "object" && !Array.isArray(obj);
    }
    Object.assign(target, config1);
    for (const key of Object.keys(config2)) {
      if (isObject(config2[key]) && isObject(target[key])) {
        target[key] = mergeDeep(config1[key], config2[key]);
      } else {
        target[key] = config2[key];
      }
    }
    return target;
  }
  function applyExtends(config, cwd, mergeExtends = false) {
    let defaultConfig = {};
    if (Object.prototype.hasOwnProperty.call(config, "extends")) {
      if (typeof config.extends !== "string")
        return defaultConfig;
      const isPath = /\.json|\..*rc$/.test(config.extends);
      let pathToDefault = null;
      if (!isPath) {
        try {
          pathToDefault = require.resolve(config.extends);
        } catch (err) {
        }
      } else {
        pathToDefault = getPathToDefaultConfig(cwd, config.extends);
      }
      if (!pathToDefault && !isPath)
        return config;
      if (!pathToDefault)
        throw new yerror_1.YError(`Unable to find extended config '${config.extends}' in '${cwd}'.`);
      checkForCircularExtends(pathToDefault);
      previouslyVisitedConfigs.push(pathToDefault);
      defaultConfig = isPath ? JSON.parse(fs.readFileSync(pathToDefault, "utf8")) : require(config.extends);
      delete config.extends;
      defaultConfig = applyExtends(defaultConfig, path2.dirname(pathToDefault), mergeExtends);
    }
    previouslyVisitedConfigs = [];
    return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);
  }
  exports2.applyExtends = applyExtends;
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/process-argv.js
var require_process_argv = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getProcessArgvBin = exports2.getProcessArgvWithoutBin = void 0;
  function getProcessArgvBinIndex() {
    if (isBundledElectronApp())
      return 0;
    return 1;
  }
  function isBundledElectronApp() {
    return isElectronApp() && !process.defaultApp;
  }
  function isElectronApp() {
    return !!process.versions.electron;
  }
  function getProcessArgvWithoutBin() {
    return process.argv.slice(getProcessArgvBinIndex() + 1);
  }
  exports2.getProcessArgvWithoutBin = getProcessArgvWithoutBin;
  function getProcessArgvBin() {
    return process.argv[getProcessArgvBinIndex()];
  }
  exports2.getProcessArgvBin = getProcessArgvBin;
});

// ../../node_modules/.pnpm/y18n@4.0.1/node_modules/y18n/index.js
var require_y18n = __commonJS((exports2, module2) => {
  var fs = require("fs");
  var path2 = require("path");
  var util = require("util");
  function Y18N(opts) {
    opts = opts || {};
    this.directory = opts.directory || "./locales";
    this.updateFiles = typeof opts.updateFiles === "boolean" ? opts.updateFiles : true;
    this.locale = opts.locale || "en";
    this.fallbackToLanguage = typeof opts.fallbackToLanguage === "boolean" ? opts.fallbackToLanguage : true;
    this.cache = Object.create(null);
    this.writeQueue = [];
  }
  Y18N.prototype.__ = function() {
    if (typeof arguments[0] !== "string") {
      return this._taggedLiteral.apply(this, arguments);
    }
    var args = Array.prototype.slice.call(arguments);
    var str = args.shift();
    var cb = function() {
    };
    if (typeof args[args.length - 1] === "function")
      cb = args.pop();
    cb = cb || function() {
    };
    if (!this.cache[this.locale])
      this._readLocaleFile();
    if (!this.cache[this.locale][str] && this.updateFiles) {
      this.cache[this.locale][str] = str;
      this._enqueueWrite([this.directory, this.locale, cb]);
    } else {
      cb();
    }
    return util.format.apply(util, [this.cache[this.locale][str] || str].concat(args));
  };
  Y18N.prototype._taggedLiteral = function(parts) {
    var args = arguments;
    var str = "";
    parts.forEach(function(part, i) {
      var arg = args[i + 1];
      str += part;
      if (typeof arg !== "undefined") {
        str += "%s";
      }
    });
    return this.__.apply(null, [str].concat([].slice.call(arguments, 1)));
  };
  Y18N.prototype._enqueueWrite = function(work) {
    this.writeQueue.push(work);
    if (this.writeQueue.length === 1)
      this._processWriteQueue();
  };
  Y18N.prototype._processWriteQueue = function() {
    var _this = this;
    var work = this.writeQueue[0];
    var directory = work[0];
    var locale = work[1];
    var cb = work[2];
    var languageFile = this._resolveLocaleFile(directory, locale);
    var serializedLocale = JSON.stringify(this.cache[locale], null, 2);
    fs.writeFile(languageFile, serializedLocale, "utf-8", function(err) {
      _this.writeQueue.shift();
      if (_this.writeQueue.length > 0)
        _this._processWriteQueue();
      cb(err);
    });
  };
  Y18N.prototype._readLocaleFile = function() {
    var localeLookup = {};
    var languageFile = this._resolveLocaleFile(this.directory, this.locale);
    try {
      localeLookup = JSON.parse(fs.readFileSync(languageFile, "utf-8"));
    } catch (err) {
      if (err instanceof SyntaxError) {
        err.message = "syntax error in " + languageFile;
      }
      if (err.code === "ENOENT")
        localeLookup = {};
      else
        throw err;
    }
    this.cache[this.locale] = localeLookup;
  };
  Y18N.prototype._resolveLocaleFile = function(directory, locale) {
    var file = path2.resolve(directory, "./", locale + ".json");
    if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf("_")) {
      var languageFile = path2.resolve(directory, "./", locale.split("_")[0] + ".json");
      if (this._fileExistsSync(languageFile))
        file = languageFile;
    }
    return file;
  };
  Y18N.prototype._fileExistsSync = function(file) {
    try {
      return fs.statSync(file).isFile();
    } catch (err) {
      return false;
    }
  };
  Y18N.prototype.__n = function() {
    var args = Array.prototype.slice.call(arguments);
    var singular = args.shift();
    var plural = args.shift();
    var quantity = args.shift();
    var cb = function() {
    };
    if (typeof args[args.length - 1] === "function")
      cb = args.pop();
    if (!this.cache[this.locale])
      this._readLocaleFile();
    var str = quantity === 1 ? singular : plural;
    if (this.cache[this.locale][singular]) {
      str = this.cache[this.locale][singular][quantity === 1 ? "one" : "other"];
    }
    if (!this.cache[this.locale][singular] && this.updateFiles) {
      this.cache[this.locale][singular] = {
        one: singular,
        other: plural
      };
      this._enqueueWrite([this.directory, this.locale, cb]);
    } else {
      cb();
    }
    var values = [str];
    if (~str.indexOf("%d"))
      values.push(quantity);
    return util.format.apply(util, values.concat(args));
  };
  Y18N.prototype.setLocale = function(locale) {
    this.locale = locale;
  };
  Y18N.prototype.getLocale = function() {
    return this.locale;
  };
  Y18N.prototype.updateLocale = function(obj) {
    if (!this.cache[this.locale])
      this._readLocaleFile();
    for (var key in obj) {
      this.cache[this.locale][key] = obj[key];
    }
  };
  module2.exports = function(opts) {
    var y18n = new Y18N(opts);
    for (var key in y18n) {
      if (typeof y18n[key] === "function") {
        y18n[key] = y18n[key].bind(y18n);
      }
    }
    return y18n;
  };
});

// ../../node_modules/.pnpm/p-try@2.2.0/node_modules/p-try/index.js
var require_p_try = __commonJS((exports2, module2) => {
  "use strict";
  var pTry = (fn, ...arguments_) => new Promise((resolve) => {
    resolve(fn(...arguments_));
  });
  module2.exports = pTry;
  module2.exports.default = pTry;
});

// ../../node_modules/.pnpm/p-limit@2.3.0/node_modules/p-limit/index.js
var require_p_limit2 = __commonJS((exports2, module2) => {
  "use strict";
  var pTry = require_p_try();
  var pLimit = (concurrency) => {
    if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
      return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
    }
    const queue = [];
    let activeCount = 0;
    const next = () => {
      activeCount--;
      if (queue.length > 0) {
        queue.shift()();
      }
    };
    const run = (fn, resolve, ...args) => {
      activeCount++;
      const result = pTry(fn, ...args);
      resolve(result);
      result.then(next, next);
    };
    const enqueue = (fn, resolve, ...args) => {
      if (activeCount < concurrency) {
        run(fn, resolve, ...args);
      } else {
        queue.push(run.bind(null, fn, resolve, ...args));
      }
    };
    const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
    Object.defineProperties(generator, {
      activeCount: {
        get: () => activeCount
      },
      pendingCount: {
        get: () => queue.length
      },
      clearQueue: {
        value: () => {
          queue.length = 0;
        }
      }
    });
    return generator;
  };
  module2.exports = pLimit;
  module2.exports.default = pLimit;
});

// ../../node_modules/.pnpm/p-locate@4.1.0/node_modules/p-locate/index.js
var require_p_locate2 = __commonJS((exports2, module2) => {
  "use strict";
  var pLimit = require_p_limit2();
  var EndError = class extends Error {
    constructor(value) {
      super();
      this.value = value;
    }
  };
  var testElement = async (element, tester) => tester(await element);
  var finder = async (element) => {
    const values = await Promise.all(element);
    if (values[1] === true) {
      throw new EndError(values[0]);
    }
    return false;
  };
  var pLocate = async (iterable, tester, options) => {
    options = {
      concurrency: Infinity,
      preserveOrder: true,
      ...options
    };
    const limit = pLimit(options.concurrency);
    const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
    const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
    try {
      await Promise.all(items.map((element) => checkLimit(finder, element)));
    } catch (error) {
      if (error instanceof EndError) {
        return error.value;
      }
      throw error;
    }
  };
  module2.exports = pLocate;
  module2.exports.default = pLocate;
});

// ../../node_modules/.pnpm/locate-path@5.0.0/node_modules/locate-path/index.js
var require_locate_path2 = __commonJS((exports2, module2) => {
  "use strict";
  var path2 = require("path");
  var fs = require("fs");
  var {promisify} = require("util");
  var pLocate = require_p_locate2();
  var fsStat = promisify(fs.stat);
  var fsLStat = promisify(fs.lstat);
  var typeMappings = {
    directory: "isDirectory",
    file: "isFile"
  };
  function checkType({type}) {
    if (type in typeMappings) {
      return;
    }
    throw new Error(`Invalid type specified: ${type}`);
  }
  var matchType = (type, stat) => type === void 0 || stat[typeMappings[type]]();
  module2.exports = async (paths, options) => {
    options = {
      cwd: process.cwd(),
      type: "file",
      allowSymlinks: true,
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fsStat : fsLStat;
    return pLocate(paths, async (path_) => {
      try {
        const stat = await statFn(path2.resolve(options.cwd, path_));
        return matchType(options.type, stat);
      } catch (_) {
        return false;
      }
    }, options);
  };
  module2.exports.sync = (paths, options) => {
    options = {
      cwd: process.cwd(),
      allowSymlinks: true,
      type: "file",
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;
    for (const path_ of paths) {
      try {
        const stat = statFn(path2.resolve(options.cwd, path_));
        if (matchType(options.type, stat)) {
          return path_;
        }
      } catch (_) {
      }
    }
  };
});

// ../../node_modules/.pnpm/find-up@4.1.0/node_modules/find-up/index.js
var require_find_up2 = __commonJS((exports2, module2) => {
  "use strict";
  var path2 = require("path");
  var locatePath = require_locate_path2();
  var pathExists = require_path_exists();
  var stop = Symbol("findUp.stop");
  module2.exports = async (name, options = {}) => {
    let directory = path2.resolve(options.cwd || "");
    const {root} = path2.parse(directory);
    const paths = [].concat(name);
    const runMatcher = async (locateOptions) => {
      if (typeof name !== "function") {
        return locatePath(paths, locateOptions);
      }
      const foundPath = await name(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = await runMatcher({...options, cwd: directory});
      if (foundPath === stop) {
        return;
      }
      if (foundPath) {
        return path2.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path2.dirname(directory);
    }
  };
  module2.exports.sync = (name, options = {}) => {
    let directory = path2.resolve(options.cwd || "");
    const {root} = path2.parse(directory);
    const paths = [].concat(name);
    const runMatcher = (locateOptions) => {
      if (typeof name !== "function") {
        return locatePath.sync(paths, locateOptions);
      }
      const foundPath = name(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath.sync([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = runMatcher({...options, cwd: directory});
      if (foundPath === stop) {
        return;
      }
      if (foundPath) {
        return path2.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path2.dirname(directory);
    }
  };
  module2.exports.exists = pathExists;
  module2.exports.sync.exists = pathExists.sync;
  module2.exports.stop = stop;
});

// ../../node_modules/.pnpm/require-main-filename@2.0.0/node_modules/require-main-filename/index.js
var require_require_main_filename = __commonJS((exports2, module2) => {
  module2.exports = function(_require) {
    _require = _require || require;
    var main = _require.main;
    if (main && isIISNode(main))
      return handleIISNode(main);
    else
      return main ? main.filename : process.cwd();
  };
  function isIISNode(main) {
    return /\\iisnode\\/.test(main.filename);
  }
  function handleIISNode(main) {
    if (!main.children.length) {
      return main.filename;
    } else {
      return main.children[0].filename;
    }
  }
});

// ../../node_modules/.pnpm/get-caller-file@2.0.5/node_modules/get-caller-file/index.js
var require_get_caller_file = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function getCallerFile(position) {
    if (position === void 0) {
      position = 2;
    }
    if (position >= Error.stackTraceLimit) {
      throw new TypeError("getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `" + position + "` and Error.stackTraceLimit was: `" + Error.stackTraceLimit + "`");
    }
    var oldPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_, stack2) {
      return stack2;
    };
    var stack = new Error().stack;
    Error.prepareStackTrace = oldPrepareStackTrace;
    if (stack !== null && typeof stack === "object") {
      return stack[position] ? stack[position].getFileName() : void 0;
    }
  };
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/build/lib/yargs.js
var require_yargs = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.isYargsInstance = exports2.rebase = exports2.Yargs = void 0;
  var command_1 = require_command();
  var common_types_1 = require_common_types();
  var yerror_1 = require_yerror();
  var usage_1 = require_usage();
  var argsert_1 = require_argsert();
  var fs = require("fs");
  var completion_1 = require_completion();
  var path2 = require("path");
  var validation_1 = require_validation();
  var obj_filter_1 = require_obj_filter();
  var apply_extends_1 = require_apply_extends();
  var middleware_1 = require_middleware();
  var processArgv = require_process_argv();
  var is_promise_1 = require_is_promise();
  var Parser = require_yargs_parser();
  var y18nFactory = require_y18n();
  var setBlocking = require_set_blocking();
  var findUp = require_find_up2();
  var requireMainFilename = require_require_main_filename();
  function Yargs(processArgs = [], cwd = process.cwd(), parentRequire = require) {
    const self = {};
    let command;
    let completion = null;
    let groups = {};
    const globalMiddleware = [];
    let output = "";
    const preservedGroups = {};
    let usage;
    let validation;
    let handlerFinishCommand = null;
    const y18n = y18nFactory({
      directory: path2.resolve(__dirname, "../../locales"),
      updateFiles: false
    });
    self.middleware = middleware_1.globalMiddlewareFactory(globalMiddleware, self);
    self.scriptName = function(scriptName) {
      self.customScriptName = true;
      self.$0 = scriptName;
      return self;
    };
    let default$0;
    if (/\b(node|iojs|electron)(\.exe)?$/.test(process.argv[0])) {
      default$0 = process.argv.slice(1, 2);
    } else {
      default$0 = process.argv.slice(0, 1);
    }
    self.$0 = default$0.map((x) => {
      const b = rebase(cwd, x);
      return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
    }).join(" ").trim();
    if (process.env._ !== void 0 && processArgv.getProcessArgvBin() === process.env._) {
      self.$0 = process.env._.replace(`${path2.dirname(process.execPath)}/`, "");
    }
    const context = {resets: -1, commands: [], fullCommands: [], files: []};
    self.getContext = () => context;
    let options;
    self.resetOptions = self.reset = function resetOptions(aliases = {}) {
      context.resets++;
      options = options || {};
      const tmpOptions = {};
      tmpOptions.local = options.local ? options.local : [];
      tmpOptions.configObjects = options.configObjects ? options.configObjects : [];
      const localLookup = {};
      tmpOptions.local.forEach((l) => {
        localLookup[l] = true;
        (aliases[l] || []).forEach((a) => {
          localLookup[a] = true;
        });
      });
      Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) => {
        const keys = groups[groupName].filter((key) => !(key in localLookup));
        if (keys.length > 0) {
          acc[groupName] = keys;
        }
        return acc;
      }, {}));
      groups = {};
      const arrayOptions = [
        "array",
        "boolean",
        "string",
        "skipValidation",
        "count",
        "normalize",
        "number",
        "hiddenOptions"
      ];
      const objectOptions = [
        "narg",
        "key",
        "alias",
        "default",
        "defaultDescription",
        "config",
        "choices",
        "demandedOptions",
        "demandedCommands",
        "coerce",
        "deprecatedOptions"
      ];
      arrayOptions.forEach((k) => {
        tmpOptions[k] = (options[k] || []).filter((k2) => !localLookup[k2]);
      });
      objectOptions.forEach((k) => {
        tmpOptions[k] = obj_filter_1.objFilter(options[k], (k2) => !localLookup[k2]);
      });
      tmpOptions.envPrefix = options.envPrefix;
      options = tmpOptions;
      usage = usage ? usage.reset(localLookup) : usage_1.usage(self, y18n);
      validation = validation ? validation.reset(localLookup) : validation_1.validation(self, usage, y18n);
      command = command ? command.reset() : command_1.command(self, usage, validation, globalMiddleware);
      if (!completion)
        completion = completion_1.completion(self, usage, command);
      completionCommand = null;
      output = "";
      exitError = null;
      hasOutput = false;
      self.parsed = false;
      return self;
    };
    self.resetOptions();
    const frozens = [];
    function freeze() {
      frozens.push({
        options,
        configObjects: options.configObjects.slice(0),
        exitProcess,
        groups,
        strict,
        strictCommands,
        completionCommand,
        output,
        exitError,
        hasOutput,
        parsed: self.parsed,
        parseFn,
        parseContext,
        handlerFinishCommand
      });
      usage.freeze();
      validation.freeze();
      command.freeze();
    }
    function unfreeze() {
      const frozen = frozens.pop();
      common_types_1.assertNotStrictEqual(frozen, void 0);
      let configObjects;
      ({
        options,
        configObjects,
        exitProcess,
        groups,
        output,
        exitError,
        hasOutput,
        parsed: self.parsed,
        strict,
        strictCommands,
        completionCommand,
        parseFn,
        parseContext,
        handlerFinishCommand
      } = frozen);
      options.configObjects = configObjects;
      usage.unfreeze();
      validation.unfreeze();
      command.unfreeze();
    }
    self.boolean = function(keys) {
      argsert_1.argsert("<array|string>", [keys], arguments.length);
      populateParserHintArray("boolean", keys);
      return self;
    };
    self.array = function(keys) {
      argsert_1.argsert("<array|string>", [keys], arguments.length);
      populateParserHintArray("array", keys);
      return self;
    };
    self.number = function(keys) {
      argsert_1.argsert("<array|string>", [keys], arguments.length);
      populateParserHintArray("number", keys);
      return self;
    };
    self.normalize = function(keys) {
      argsert_1.argsert("<array|string>", [keys], arguments.length);
      populateParserHintArray("normalize", keys);
      return self;
    };
    self.count = function(keys) {
      argsert_1.argsert("<array|string>", [keys], arguments.length);
      populateParserHintArray("count", keys);
      return self;
    };
    self.string = function(keys) {
      argsert_1.argsert("<array|string>", [keys], arguments.length);
      populateParserHintArray("string", keys);
      return self;
    };
    self.requiresArg = function(keys) {
      argsert_1.argsert("<array|string|object> [number]", [keys], arguments.length);
      if (typeof keys === "string" && options.narg[keys]) {
        return self;
      } else {
        populateParserHintSingleValueDictionary(self.requiresArg, "narg", keys, NaN);
      }
      return self;
    };
    self.skipValidation = function(keys) {
      argsert_1.argsert("<array|string>", [keys], arguments.length);
      populateParserHintArray("skipValidation", keys);
      return self;
    };
    function populateParserHintArray(type, keys) {
      keys = [].concat(keys);
      keys.forEach((key) => {
        key = sanitizeKey(key);
        options[type].push(key);
      });
    }
    self.nargs = function(key, value) {
      argsert_1.argsert("<string|object|array> [number]", [key, value], arguments.length);
      populateParserHintSingleValueDictionary(self.nargs, "narg", key, value);
      return self;
    };
    self.choices = function(key, value) {
      argsert_1.argsert("<object|string|array> [string|array]", [key, value], arguments.length);
      populateParserHintArrayDictionary(self.choices, "choices", key, value);
      return self;
    };
    self.alias = function(key, value) {
      argsert_1.argsert("<object|string|array> [string|array]", [key, value], arguments.length);
      populateParserHintArrayDictionary(self.alias, "alias", key, value);
      return self;
    };
    self.default = self.defaults = function(key, value, defaultDescription) {
      argsert_1.argsert("<object|string|array> [*] [string]", [key, value, defaultDescription], arguments.length);
      if (defaultDescription) {
        common_types_1.assertSingleKey(key);
        options.defaultDescription[key] = defaultDescription;
      }
      if (typeof value === "function") {
        common_types_1.assertSingleKey(key);
        if (!options.defaultDescription[key])
          options.defaultDescription[key] = usage.functionDescription(value);
        value = value.call();
      }
      populateParserHintSingleValueDictionary(self.default, "default", key, value);
      return self;
    };
    self.describe = function(key, desc) {
      argsert_1.argsert("<object|string|array> [string]", [key, desc], arguments.length);
      setKey(key, true);
      usage.describe(key, desc);
      return self;
    };
    function setKey(key, set) {
      populateParserHintSingleValueDictionary(setKey, "key", key, set);
      return self;
    }
    function demandOption(keys, msg) {
      argsert_1.argsert("<object|string|array> [string]", [keys, msg], arguments.length);
      populateParserHintSingleValueDictionary(self.demandOption, "demandedOptions", keys, msg);
      return self;
    }
    self.demandOption = demandOption;
    self.coerce = function(keys, value) {
      argsert_1.argsert("<object|string|array> [function]", [keys, value], arguments.length);
      populateParserHintSingleValueDictionary(self.coerce, "coerce", keys, value);
      return self;
    };
    function populateParserHintSingleValueDictionary(builder, type, key, value) {
      populateParserHintDictionary(builder, type, key, value, (type2, key2, value2) => {
        options[type2][key2] = value2;
      });
    }
    function populateParserHintArrayDictionary(builder, type, key, value) {
      populateParserHintDictionary(builder, type, key, value, (type2, key2, value2) => {
        options[type2][key2] = (options[type2][key2] || []).concat(value2);
      });
    }
    function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {
      if (Array.isArray(key)) {
        key.forEach((k) => {
          builder(k, value);
        });
      } else if (((key2) => typeof key2 === "object")(key)) {
        for (const k of common_types_1.objectKeys(key)) {
          builder(k, key[k]);
        }
      } else {
        singleKeyHandler(type, sanitizeKey(key), value);
      }
    }
    function sanitizeKey(key) {
      if (key === "__proto__")
        return "___proto___";
      return key;
    }
    function deleteFromParserHintObject(optionKey) {
      common_types_1.objectKeys(options).forEach((hintKey) => {
        if (((key) => key === "configObjects")(hintKey))
          return;
        const hint = options[hintKey];
        if (Array.isArray(hint)) {
          if (~hint.indexOf(optionKey))
            hint.splice(hint.indexOf(optionKey), 1);
        } else if (typeof hint === "object") {
          delete hint[optionKey];
        }
      });
      delete usage.getDescriptions()[optionKey];
    }
    self.config = function config(key = "config", msg, parseFn2) {
      argsert_1.argsert("[object|string] [string|function] [function]", [key, msg, parseFn2], arguments.length);
      if (typeof key === "object" && !Array.isArray(key)) {
        key = apply_extends_1.applyExtends(key, cwd, self.getParserConfiguration()["deep-merge-config"]);
        options.configObjects = (options.configObjects || []).concat(key);
        return self;
      }
      if (typeof msg === "function") {
        parseFn2 = msg;
        msg = void 0;
      }
      self.describe(key, msg || usage.deferY18nLookup("Path to JSON config file"));
      (Array.isArray(key) ? key : [key]).forEach((k) => {
        options.config[k] = parseFn2 || true;
      });
      return self;
    };
    self.example = function(cmd, description) {
      argsert_1.argsert("<string|array> [string]", [cmd, description], arguments.length);
      if (Array.isArray(cmd)) {
        cmd.forEach((exampleParams) => self.example(...exampleParams));
      } else {
        usage.example(cmd, description);
      }
      return self;
    };
    self.command = function(cmd, description, builder, handler, middlewares, deprecated) {
      argsert_1.argsert("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [cmd, description, builder, handler, middlewares, deprecated], arguments.length);
      command.addHandler(cmd, description, builder, handler, middlewares, deprecated);
      return self;
    };
    self.commandDir = function(dir, opts) {
      argsert_1.argsert("<string> [object]", [dir, opts], arguments.length);
      const req = parentRequire || require;
      command.addDirectory(dir, self.getContext(), req, require_get_caller_file()(), opts);
      return self;
    };
    self.demand = self.required = self.require = function demand(keys, max, msg) {
      if (Array.isArray(max)) {
        max.forEach((key) => {
          common_types_1.assertNotStrictEqual(msg, true);
          demandOption(key, msg);
        });
        max = Infinity;
      } else if (typeof max !== "number") {
        msg = max;
        max = Infinity;
      }
      if (typeof keys === "number") {
        common_types_1.assertNotStrictEqual(msg, true);
        self.demandCommand(keys, max, msg, msg);
      } else if (Array.isArray(keys)) {
        keys.forEach((key) => {
          common_types_1.assertNotStrictEqual(msg, true);
          demandOption(key, msg);
        });
      } else {
        if (typeof msg === "string") {
          demandOption(keys, msg);
        } else if (msg === true || typeof msg === "undefined") {
          demandOption(keys);
        }
      }
      return self;
    };
    self.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) {
      argsert_1.argsert("[number] [number|string] [string|null|undefined] [string|null|undefined]", [min, max, minMsg, maxMsg], arguments.length);
      if (typeof max !== "number") {
        minMsg = max;
        max = Infinity;
      }
      self.global("_", false);
      options.demandedCommands._ = {
        min,
        max,
        minMsg,
        maxMsg
      };
      return self;
    };
    self.getDemandedOptions = () => {
      argsert_1.argsert([], 0);
      return options.demandedOptions;
    };
    self.getDemandedCommands = () => {
      argsert_1.argsert([], 0);
      return options.demandedCommands;
    };
    self.deprecateOption = function deprecateOption(option, message) {
      argsert_1.argsert("<string> [string|boolean]", [option, message], arguments.length);
      options.deprecatedOptions[option] = message;
      return self;
    };
    self.getDeprecatedOptions = () => {
      argsert_1.argsert([], 0);
      return options.deprecatedOptions;
    };
    self.implies = function(key, value) {
      argsert_1.argsert("<string|object> [number|string|array]", [key, value], arguments.length);
      validation.implies(key, value);
      return self;
    };
    self.conflicts = function(key1, key2) {
      argsert_1.argsert("<string|object> [string|array]", [key1, key2], arguments.length);
      validation.conflicts(key1, key2);
      return self;
    };
    self.usage = function(msg, description, builder, handler) {
      argsert_1.argsert("<string|null|undefined> [string|boolean] [function|object] [function]", [msg, description, builder, handler], arguments.length);
      if (description !== void 0) {
        common_types_1.assertNotStrictEqual(msg, null);
        if ((msg || "").match(/^\$0( |$)/)) {
          return self.command(msg, description, builder, handler);
        } else {
          throw new yerror_1.YError(".usage() description must start with $0 if being used as alias for .command()");
        }
      } else {
        usage.usage(msg);
        return self;
      }
    };
    self.epilogue = self.epilog = function(msg) {
      argsert_1.argsert("<string>", [msg], arguments.length);
      usage.epilog(msg);
      return self;
    };
    self.fail = function(f) {
      argsert_1.argsert("<function>", [f], arguments.length);
      usage.failFn(f);
      return self;
    };
    self.onFinishCommand = function(f) {
      argsert_1.argsert("<function>", [f], arguments.length);
      handlerFinishCommand = f;
      return self;
    };
    self.getHandlerFinishCommand = () => handlerFinishCommand;
    self.check = function(f, _global) {
      argsert_1.argsert("<function> [boolean]", [f, _global], arguments.length);
      validation.check(f, _global !== false);
      return self;
    };
    self.global = function global2(globals, global2) {
      argsert_1.argsert("<string|array> [boolean]", [globals, global2], arguments.length);
      globals = [].concat(globals);
      if (global2 !== false) {
        options.local = options.local.filter((l) => globals.indexOf(l) === -1);
      } else {
        globals.forEach((g) => {
          if (options.local.indexOf(g) === -1)
            options.local.push(g);
        });
      }
      return self;
    };
    self.pkgConf = function pkgConf(key, rootPath) {
      argsert_1.argsert("<string> [string]", [key, rootPath], arguments.length);
      let conf = null;
      const obj = pkgUp(rootPath || cwd);
      if (obj[key] && typeof obj[key] === "object") {
        conf = apply_extends_1.applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()["deep-merge-config"]);
        options.configObjects = (options.configObjects || []).concat(conf);
      }
      return self;
    };
    const pkgs = {};
    function pkgUp(rootPath) {
      const npath = rootPath || "*";
      if (pkgs[npath])
        return pkgs[npath];
      let obj = {};
      try {
        let startDir = rootPath || requireMainFilename(parentRequire);
        if (!rootPath && path2.extname(startDir)) {
          startDir = path2.dirname(startDir);
        }
        const pkgJsonPath = findUp.sync("package.json", {
          cwd: startDir
        });
        common_types_1.assertNotStrictEqual(pkgJsonPath, void 0);
        obj = JSON.parse(fs.readFileSync(pkgJsonPath).toString());
      } catch (noop) {
      }
      pkgs[npath] = obj || {};
      return pkgs[npath];
    }
    let parseFn = null;
    let parseContext = null;
    self.parse = function parse(args, shortCircuit, _parseFn) {
      argsert_1.argsert("[string|array] [function|boolean|object] [function]", [args, shortCircuit, _parseFn], arguments.length);
      freeze();
      if (typeof args === "undefined") {
        const argv = self._parseArgs(processArgs);
        const tmpParsed = self.parsed;
        unfreeze();
        self.parsed = tmpParsed;
        return argv;
      }
      if (typeof shortCircuit === "object") {
        parseContext = shortCircuit;
        shortCircuit = _parseFn;
      }
      if (typeof shortCircuit === "function") {
        parseFn = shortCircuit;
        shortCircuit = false;
      }
      if (!shortCircuit)
        processArgs = args;
      if (parseFn)
        exitProcess = false;
      const parsed = self._parseArgs(args, !!shortCircuit);
      completion.setParsed(self.parsed);
      if (parseFn)
        parseFn(exitError, parsed, output);
      unfreeze();
      return parsed;
    };
    self._getParseContext = () => parseContext || {};
    self._hasParseCallback = () => !!parseFn;
    self.option = self.options = function option(key, opt) {
      argsert_1.argsert("<string|object> [object]", [key, opt], arguments.length);
      if (typeof key === "object") {
        Object.keys(key).forEach((k) => {
          self.options(k, key[k]);
        });
      } else {
        if (typeof opt !== "object") {
          opt = {};
        }
        options.key[key] = true;
        if (opt.alias)
          self.alias(key, opt.alias);
        const deprecate = opt.deprecate || opt.deprecated;
        if (deprecate) {
          self.deprecateOption(key, deprecate);
        }
        const demand = opt.demand || opt.required || opt.require;
        if (demand) {
          self.demand(key, demand);
        }
        if (opt.demandOption) {
          self.demandOption(key, typeof opt.demandOption === "string" ? opt.demandOption : void 0);
        }
        if (opt.conflicts) {
          self.conflicts(key, opt.conflicts);
        }
        if ("default" in opt) {
          self.default(key, opt.default);
        }
        if (opt.implies !== void 0) {
          self.implies(key, opt.implies);
        }
        if (opt.nargs !== void 0) {
          self.nargs(key, opt.nargs);
        }
        if (opt.config) {
          self.config(key, opt.configParser);
        }
        if (opt.normalize) {
          self.normalize(key);
        }
        if (opt.choices) {
          self.choices(key, opt.choices);
        }
        if (opt.coerce) {
          self.coerce(key, opt.coerce);
        }
        if (opt.group) {
          self.group(key, opt.group);
        }
        if (opt.boolean || opt.type === "boolean") {
          self.boolean(key);
          if (opt.alias)
            self.boolean(opt.alias);
        }
        if (opt.array || opt.type === "array") {
          self.array(key);
          if (opt.alias)
            self.array(opt.alias);
        }
        if (opt.number || opt.type === "number") {
          self.number(key);
          if (opt.alias)
            self.number(opt.alias);
        }
        if (opt.string || opt.type === "string") {
          self.string(key);
          if (opt.alias)
            self.string(opt.alias);
        }
        if (opt.count || opt.type === "count") {
          self.count(key);
        }
        if (typeof opt.global === "boolean") {
          self.global(key, opt.global);
        }
        if (opt.defaultDescription) {
          options.defaultDescription[key] = opt.defaultDescription;
        }
        if (opt.skipValidation) {
          self.skipValidation(key);
        }
        const desc = opt.describe || opt.description || opt.desc;
        self.describe(key, desc);
        if (opt.hidden) {
          self.hide(key);
        }
        if (opt.requiresArg) {
          self.requiresArg(key);
        }
      }
      return self;
    };
    self.getOptions = () => options;
    self.positional = function(key, opts) {
      argsert_1.argsert("<string> <object>", [key, opts], arguments.length);
      if (context.resets === 0) {
        throw new yerror_1.YError(".positional() can only be called in a command's builder function");
      }
      const supportedOpts = [
        "default",
        "defaultDescription",
        "implies",
        "normalize",
        "choices",
        "conflicts",
        "coerce",
        "type",
        "describe",
        "desc",
        "description",
        "alias"
      ];
      opts = obj_filter_1.objFilter(opts, (k, v) => {
        let accept = supportedOpts.indexOf(k) !== -1;
        if (k === "type" && ["string", "number", "boolean"].indexOf(v) === -1)
          accept = false;
        return accept;
      });
      const fullCommand = context.fullCommands[context.fullCommands.length - 1];
      const parseOptions = fullCommand ? command.cmdToParseOptions(fullCommand) : {
        array: [],
        alias: {},
        default: {},
        demand: {}
      };
      common_types_1.objectKeys(parseOptions).forEach((pk) => {
        const parseOption = parseOptions[pk];
        if (Array.isArray(parseOption)) {
          if (parseOption.indexOf(key) !== -1)
            opts[pk] = true;
        } else {
          if (parseOption[key] && !(pk in opts))
            opts[pk] = parseOption[key];
        }
      });
      self.group(key, usage.getPositionalGroupName());
      return self.option(key, opts);
    };
    self.group = function group(opts, groupName) {
      argsert_1.argsert("<string|array> <string>", [opts, groupName], arguments.length);
      const existing = preservedGroups[groupName] || groups[groupName];
      if (preservedGroups[groupName]) {
        delete preservedGroups[groupName];
      }
      const seen = {};
      groups[groupName] = (existing || []).concat(opts).filter((key) => {
        if (seen[key])
          return false;
        return seen[key] = true;
      });
      return self;
    };
    self.getGroups = () => Object.assign({}, groups, preservedGroups);
    self.env = function(prefix) {
      argsert_1.argsert("[string|boolean]", [prefix], arguments.length);
      if (prefix === false)
        delete options.envPrefix;
      else
        options.envPrefix = prefix || "";
      return self;
    };
    self.wrap = function(cols) {
      argsert_1.argsert("<number|null|undefined>", [cols], arguments.length);
      usage.wrap(cols);
      return self;
    };
    let strict = false;
    self.strict = function(enabled) {
      argsert_1.argsert("[boolean]", [enabled], arguments.length);
      strict = enabled !== false;
      return self;
    };
    self.getStrict = () => strict;
    let strictCommands = false;
    self.strictCommands = function(enabled) {
      argsert_1.argsert("[boolean]", [enabled], arguments.length);
      strictCommands = enabled !== false;
      return self;
    };
    self.getStrictCommands = () => strictCommands;
    let parserConfig = {};
    self.parserConfiguration = function parserConfiguration(config) {
      argsert_1.argsert("<object>", [config], arguments.length);
      parserConfig = config;
      return self;
    };
    self.getParserConfiguration = () => parserConfig;
    self.showHelp = function(level) {
      argsert_1.argsert("[string|function]", [level], arguments.length);
      if (!self.parsed)
        self._parseArgs(processArgs);
      if (command.hasDefaultCommand()) {
        context.resets++;
        command.runDefaultBuilderOn(self);
      }
      usage.showHelp(level);
      return self;
    };
    let versionOpt = null;
    self.version = function version(opt, msg, ver) {
      const defaultVersionOpt = "version";
      argsert_1.argsert("[boolean|string] [string] [string]", [opt, msg, ver], arguments.length);
      if (versionOpt) {
        deleteFromParserHintObject(versionOpt);
        usage.version(void 0);
        versionOpt = null;
      }
      if (arguments.length === 0) {
        ver = guessVersion();
        opt = defaultVersionOpt;
      } else if (arguments.length === 1) {
        if (opt === false) {
          return self;
        }
        ver = opt;
        opt = defaultVersionOpt;
      } else if (arguments.length === 2) {
        ver = msg;
        msg = void 0;
      }
      versionOpt = typeof opt === "string" ? opt : defaultVersionOpt;
      msg = msg || usage.deferY18nLookup("Show version number");
      usage.version(ver || void 0);
      self.boolean(versionOpt);
      self.describe(versionOpt, msg);
      return self;
    };
    function guessVersion() {
      const obj = pkgUp();
      return obj.version || "unknown";
    }
    let helpOpt = null;
    self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {
      const defaultHelpOpt = "help";
      argsert_1.argsert("[string|boolean] [string]", [opt, msg], arguments.length);
      if (helpOpt) {
        deleteFromParserHintObject(helpOpt);
        helpOpt = null;
      }
      if (arguments.length === 1) {
        if (opt === false)
          return self;
      }
      helpOpt = typeof opt === "string" ? opt : defaultHelpOpt;
      self.boolean(helpOpt);
      self.describe(helpOpt, msg || usage.deferY18nLookup("Show help"));
      return self;
    };
    const defaultShowHiddenOpt = "show-hidden";
    options.showHiddenOpt = defaultShowHiddenOpt;
    self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) {
      argsert_1.argsert("[string|boolean] [string]", [opt, msg], arguments.length);
      if (arguments.length === 1) {
        if (opt === false)
          return self;
      }
      const showHiddenOpt = typeof opt === "string" ? opt : defaultShowHiddenOpt;
      self.boolean(showHiddenOpt);
      self.describe(showHiddenOpt, msg || usage.deferY18nLookup("Show hidden options"));
      options.showHiddenOpt = showHiddenOpt;
      return self;
    };
    self.hide = function hide(key) {
      argsert_1.argsert("<string>", [key], arguments.length);
      options.hiddenOptions.push(key);
      return self;
    };
    self.showHelpOnFail = function showHelpOnFail(enabled, message) {
      argsert_1.argsert("[boolean|string] [string]", [enabled, message], arguments.length);
      usage.showHelpOnFail(enabled, message);
      return self;
    };
    var exitProcess = true;
    self.exitProcess = function(enabled = true) {
      argsert_1.argsert("[boolean]", [enabled], arguments.length);
      exitProcess = enabled;
      return self;
    };
    self.getExitProcess = () => exitProcess;
    var completionCommand = null;
    self.completion = function(cmd, desc, fn) {
      argsert_1.argsert("[string] [string|boolean|function] [function]", [cmd, desc, fn], arguments.length);
      if (typeof desc === "function") {
        fn = desc;
        desc = void 0;
      }
      completionCommand = cmd || completionCommand || "completion";
      if (!desc && desc !== false) {
        desc = "generate completion script";
      }
      self.command(completionCommand, desc);
      if (fn)
        completion.registerFunction(fn);
      return self;
    };
    self.showCompletionScript = function($0, cmd) {
      argsert_1.argsert("[string] [string]", [$0, cmd], arguments.length);
      $0 = $0 || self.$0;
      _logger.log(completion.generateCompletionScript($0, cmd || completionCommand || "completion"));
      return self;
    };
    self.getCompletion = function(args, done) {
      argsert_1.argsert("<array> <function>", [args, done], arguments.length);
      completion.getCompletion(args, done);
    };
    self.locale = function(locale) {
      argsert_1.argsert("[string]", [locale], arguments.length);
      if (!locale) {
        guessLocale();
        return y18n.getLocale();
      }
      detectLocale = false;
      y18n.setLocale(locale);
      return self;
    };
    self.updateStrings = self.updateLocale = function(obj) {
      argsert_1.argsert("<object>", [obj], arguments.length);
      detectLocale = false;
      y18n.updateLocale(obj);
      return self;
    };
    let detectLocale = true;
    self.detectLocale = function(detect) {
      argsert_1.argsert("<boolean>", [detect], arguments.length);
      detectLocale = detect;
      return self;
    };
    self.getDetectLocale = () => detectLocale;
    var hasOutput = false;
    var exitError = null;
    self.exit = (code, err) => {
      hasOutput = true;
      exitError = err;
      if (exitProcess)
        process.exit(code);
    };
    const _logger = {
      log(...args) {
        if (!self._hasParseCallback())
          console.log(...args);
        hasOutput = true;
        if (output.length)
          output += "\n";
        output += args.join(" ");
      },
      error(...args) {
        if (!self._hasParseCallback())
          console.error(...args);
        hasOutput = true;
        if (output.length)
          output += "\n";
        output += args.join(" ");
      }
    };
    self._getLoggerInstance = () => _logger;
    self._hasOutput = () => hasOutput;
    self._setHasOutput = () => {
      hasOutput = true;
    };
    let recommendCommands;
    self.recommendCommands = function(recommend = true) {
      argsert_1.argsert("[boolean]", [recommend], arguments.length);
      recommendCommands = recommend;
      return self;
    };
    self.getUsageInstance = () => usage;
    self.getValidationInstance = () => validation;
    self.getCommandInstance = () => command;
    self.terminalWidth = () => {
      argsert_1.argsert([], 0);
      return typeof process.stdout.columns !== "undefined" ? process.stdout.columns : null;
    };
    Object.defineProperty(self, "argv", {
      get: () => self._parseArgs(processArgs),
      enumerable: true
    });
    self._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) {
      let skipValidation = !!_calledFromCommand;
      args = args || processArgs;
      options.__ = y18n.__;
      options.configuration = self.getParserConfiguration();
      const populateDoubleDash = !!options.configuration["populate--"];
      const config = Object.assign({}, options.configuration, {
        "populate--": true
      });
      const parsed = Parser.detailed(args, Object.assign({}, options, {
        configuration: config
      }));
      let argv = parsed.argv;
      if (parseContext)
        argv = Object.assign({}, argv, parseContext);
      const aliases = parsed.aliases;
      argv.$0 = self.$0;
      self.parsed = parsed;
      try {
        guessLocale();
        if (shortCircuit) {
          return populateDoubleDash || _calledFromCommand ? argv : self._copyDoubleDash(argv);
        }
        if (helpOpt) {
          const helpCmds = [helpOpt].concat(aliases[helpOpt] || []).filter((k) => k.length > 1);
          if (~helpCmds.indexOf(argv._[argv._.length - 1])) {
            argv._.pop();
            argv[helpOpt] = true;
          }
        }
        const handlerKeys = command.getCommands();
        const requestCompletions = completion.completionKey in argv;
        const skipRecommendation = argv[helpOpt] || requestCompletions;
        const skipDefaultCommand = skipRecommendation && (handlerKeys.length > 1 || handlerKeys[0] !== "$0");
        if (argv._.length) {
          if (handlerKeys.length) {
            let firstUnknownCommand;
            for (let i = commandIndex || 0, cmd; argv._[i] !== void 0; i++) {
              cmd = String(argv._[i]);
              if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {
                const innerArgv = command.runCommand(cmd, self, parsed, i + 1);
                return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);
              } else if (!firstUnknownCommand && cmd !== completionCommand) {
                firstUnknownCommand = cmd;
                break;
              }
            }
            if (command.hasDefaultCommand() && !skipDefaultCommand) {
              const innerArgv = command.runCommand(null, self, parsed);
              return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);
            }
            if (recommendCommands && firstUnknownCommand && !skipRecommendation) {
              validation.recommendCommands(firstUnknownCommand, handlerKeys);
            }
          }
          if (completionCommand && ~argv._.indexOf(completionCommand) && !requestCompletions) {
            if (exitProcess)
              setBlocking(true);
            self.showCompletionScript();
            self.exit(0);
          }
        } else if (command.hasDefaultCommand() && !skipDefaultCommand) {
          const innerArgv = command.runCommand(null, self, parsed);
          return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);
        }
        if (requestCompletions) {
          if (exitProcess)
            setBlocking(true);
          args = [].concat(args);
          const completionArgs = args.slice(args.indexOf(`--${completion.completionKey}`) + 1);
          completion.getCompletion(completionArgs, (completions) => {
            ;
            (completions || []).forEach((completion2) => {
              _logger.log(completion2);
            });
            self.exit(0);
          });
          return populateDoubleDash || _calledFromCommand ? argv : self._copyDoubleDash(argv);
        }
        if (!hasOutput) {
          Object.keys(argv).forEach((key) => {
            if (key === helpOpt && argv[key]) {
              if (exitProcess)
                setBlocking(true);
              skipValidation = true;
              self.showHelp("log");
              self.exit(0);
            } else if (key === versionOpt && argv[key]) {
              if (exitProcess)
                setBlocking(true);
              skipValidation = true;
              usage.showVersion();
              self.exit(0);
            }
          });
        }
        if (!skipValidation && options.skipValidation.length > 0) {
          skipValidation = Object.keys(argv).some((key) => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);
        }
        if (!skipValidation) {
          if (parsed.error)
            throw new yerror_1.YError(parsed.error.message);
          if (!requestCompletions) {
            self._runValidation(argv, aliases, {}, parsed.error);
          }
        }
      } catch (err) {
        if (err instanceof yerror_1.YError)
          usage.fail(err.message, err);
        else
          throw err;
      }
      return populateDoubleDash || _calledFromCommand ? argv : self._copyDoubleDash(argv);
    };
    self._copyDoubleDash = function(argv) {
      if (is_promise_1.isPromise(argv) || !argv._ || !argv["--"])
        return argv;
      argv._.push.apply(argv._, argv["--"]);
      try {
        delete argv["--"];
      } catch (_err) {
      }
      return argv;
    };
    self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) {
      if (parseErrors)
        throw new yerror_1.YError(parseErrors.message);
      validation.nonOptionCount(argv);
      validation.requiredArguments(argv);
      let failedStrictCommands = false;
      if (strictCommands) {
        failedStrictCommands = validation.unknownCommands(argv);
      }
      if (strict && !failedStrictCommands) {
        validation.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);
      }
      validation.customChecks(argv, aliases);
      validation.limitedChoices(argv);
      validation.implications(argv);
      validation.conflicting(argv);
    };
    function guessLocale() {
      if (!detectLocale)
        return;
      const locale = process.env.LC_ALL || process.env.LC_MESSAGES || process.env.LANG || process.env.LANGUAGE || "en_US";
      self.locale(locale.replace(/[.:].*/, ""));
    }
    self.help();
    self.version();
    return self;
  }
  exports2.Yargs = Yargs;
  function rebase(base, dir) {
    return path2.relative(base, dir);
  }
  exports2.rebase = rebase;
  function isYargsInstance(y) {
    return !!y && typeof y._parseArgs === "function";
  }
  exports2.isYargsInstance = isYargsInstance;
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/yargs.js
var require_yargs2 = __commonJS((exports2, module2) => {
  "use strict";
  async function requiresNode8OrGreater() {
  }
  requiresNode8OrGreater();
  var {Yargs, rebase} = require_yargs();
  var Parser = require_yargs_parser();
  exports2 = module2.exports = Yargs;
  exports2.rebase = rebase;
  exports2.Parser = Parser;
});

// ../../node_modules/.pnpm/yargs@15.4.1/node_modules/yargs/index.js
var require_yargs3 = __commonJS((exports2, module2) => {
  "use strict";
  var yargs = require_yargs2();
  var processArgv = require_process_argv();
  Argv(processArgv.getProcessArgvWithoutBin());
  module2.exports = Argv;
  function Argv(processArgs, cwd) {
    const argv = yargs(processArgs, cwd, require);
    singletonify(argv);
    return argv;
  }
  function singletonify(inst) {
    Object.keys(inst).forEach((key) => {
      if (key === "argv") {
        Argv.__defineGetter__(key, inst.__lookupGetter__(key));
      } else if (typeof inst[key] === "function") {
        Argv[key] = inst[key].bind(inst);
      } else {
        Argv.__defineGetter__("$0", () => {
          return inst.$0;
        });
        Argv.__defineGetter__("parsed", () => {
          return inst.parsed;
        });
      }
    });
  }
});

// ../../node_modules/.pnpm/@zkochan#libnpx@11.0.3/node_modules/@zkochan/libnpx/y.js
var require_y = __commonJS((exports2, module2) => {
  "use strict";
  var path2 = require("path");
  var yargs = require_yargs3();
  var y18n = require_y18n()({
    directory: path2.join(__dirname, "locales"),
    locale: yargs.locale(),
    updateFiles: process.env.NPX_UPDATE_LOCALE_FILES === "true"
  });
  module2.exports = yTag;
  function yTag(parts) {
    let str = "";
    parts.forEach((part, i) => {
      str += part;
      if (arguments.length > i + 1) {
        str += "%s";
      }
    });
    return y18n.__.apply(null, [str].concat([].slice.call(arguments, 1)));
  }
});

// ../../node_modules/.pnpm/@zkochan#libnpx@11.0.3/node_modules/@zkochan/libnpx/child.js
var require_child = __commonJS((exports2, module2) => {
  "use strict";
  var cp = require("child_process");
  var path2 = require("path");
  module2.exports.runCommand = runCommand;
  function runCommand(command, opts) {
    const cmd = opts.call || command || opts.command;
    const copts = (opts.call ? [] : opts.cmdOpts) || [];
    return spawn(cmd, copts, {
      shell: opts.shell || !!opts.call,
      stdio: opts.stdio || "inherit"
    }).catch((err) => {
      if (err.code === "ENOENT") {
        err = new Error(`npx: ${require_y()`command not found: ${path2.basename(cmd)}`}`);
        err.exitCode = 127;
      } else {
        err.message = require_y()`Command failed: ${cmd} ${err.message}`;
      }
      throw err;
    });
  }
  module2.exports.spawn = spawn;
  function spawn(cmd, args, opts) {
    opts = opts || {};
    opts.shell = opts.shell || process.platform === "win32";
    return new Promise((resolve, reject) => {
      const child = cp.spawn(cmd, args, opts);
      let stdout = "";
      let stderr = "";
      child.stdout && child.stdout.on("data", (d) => {
        stdout += d;
      });
      child.stderr && child.stderr.on("data", (d) => {
        stderr += d;
      });
      child.on("error", reject);
      child.on("close", (code) => {
        if (code) {
          const err = new Error(require_y()`Command failed: ${cmd} ${args.join(" ")}`);
          err.isOperational = true;
          err.stderr = stderr;
          err.exitCode = code;
          reject(err);
        } else {
          resolve({code, stdout, stderr});
        }
      });
    });
  }
  module2.exports.exec = exec;
  function exec(cmd, args, opts) {
    opts = opts || {};
    return new Promise((resolve, reject) => {
      cp.exec(`${escapeArg(cmd, true)} ${args.join(" ")}`, opts, (err, stdout) => {
        if (err) {
          if (typeof err.code === "number") {
            err.exitCode = err.code;
          }
          reject(err);
        } else {
          resolve(stdout);
        }
      });
    });
  }
  module2.exports.escapeArg = escapeArg;
  function escapeArg(str, asPath) {
    return process.platform === "win32" && asPath ? path2.normalize(str).split(/\\/).map((s) => s.match(/\s+/) ? `"${s}"` : s).join("\\") : process.platform === "win32" ? `"${str}"` : str.match(/[^-_.~/\w]/) ? `'${str.replace(/'/g, `'"'"'`)}'` : str;
  }
});

// ../../node_modules/.pnpm/builtins@1.0.3/node_modules/builtins/builtins.json
var require_builtins = __commonJS((exports2, module2) => {
  module2.exports = [
    "assert",
    "buffer",
    "child_process",
    "cluster",
    "console",
    "constants",
    "crypto",
    "dgram",
    "dns",
    "domain",
    "events",
    "fs",
    "http",
    "https",
    "module",
    "net",
    "os",
    "path",
    "process",
    "punycode",
    "querystring",
    "readline",
    "repl",
    "stream",
    "string_decoder",
    "timers",
    "tls",
    "tty",
    "url",
    "util",
    "v8",
    "vm",
    "zlib"
  ];
});

// ../../node_modules/.pnpm/validate-npm-package-name@3.0.0/node_modules/validate-npm-package-name/index.js
var require_validate_npm_package_name = __commonJS((exports2, module2) => {
  "use strict";
  var scopedPackagePattern = new RegExp("^(?:@([^/]+?)[/])?([^/]+?)$");
  var builtins = require_builtins();
  var blacklist = [
    "node_modules",
    "favicon.ico"
  ];
  var validate = module2.exports = function(name) {
    var warnings = [];
    var errors = [];
    if (name === null) {
      errors.push("name cannot be null");
      return done(warnings, errors);
    }
    if (name === void 0) {
      errors.push("name cannot be undefined");
      return done(warnings, errors);
    }
    if (typeof name !== "string") {
      errors.push("name must be a string");
      return done(warnings, errors);
    }
    if (!name.length) {
      errors.push("name length must be greater than zero");
    }
    if (name.match(/^\./)) {
      errors.push("name cannot start with a period");
    }
    if (name.match(/^_/)) {
      errors.push("name cannot start with an underscore");
    }
    if (name.trim() !== name) {
      errors.push("name cannot contain leading or trailing spaces");
    }
    blacklist.forEach(function(blacklistedName) {
      if (name.toLowerCase() === blacklistedName) {
        errors.push(blacklistedName + " is a blacklisted name");
      }
    });
    builtins.forEach(function(builtin) {
      if (name.toLowerCase() === builtin) {
        warnings.push(builtin + " is a core module name");
      }
    });
    if (name.length > 214) {
      warnings.push("name can no longer contain more than 214 characters");
    }
    if (name.toLowerCase() !== name) {
      warnings.push("name can no longer contain capital letters");
    }
    if (/[~'!()*]/.test(name.split("/").slice(-1)[0])) {
      warnings.push(`name can no longer contain special characters ("~'!()*")`);
    }
    if (encodeURIComponent(name) !== name) {
      var nameMatch = name.match(scopedPackagePattern);
      if (nameMatch) {
        var user = nameMatch[1];
        var pkg = nameMatch[2];
        if (encodeURIComponent(user) === user && encodeURIComponent(pkg) === pkg) {
          return done(warnings, errors);
        }
      }
      errors.push("name can only contain URL-friendly characters");
    }
    return done(warnings, errors);
  };
  validate.scopedPackagePattern = scopedPackagePattern;
  var done = function(warnings, errors) {
    var result = {
      validForNewPackages: errors.length === 0 && warnings.length === 0,
      validForOldPackages: errors.length === 0,
      warnings,
      errors
    };
    if (!result.warnings.length)
      delete result.warnings;
    if (!result.errors.length)
      delete result.errors;
    return result;
  };
});

// ../../node_modules/.pnpm/hosted-git-info@2.8.8/node_modules/hosted-git-info/git-host-info.js
var require_git_host_info = __commonJS((exports2, module2) => {
  "use strict";
  var gitHosts = module2.exports = {
    github: {
      protocols: ["git", "http", "git+ssh", "git+https", "ssh", "https"],
      domain: "github.com",
      treepath: "tree",
      filetemplate: "https://{auth@}raw.githubusercontent.com/{user}/{project}/{committish}/{path}",
      bugstemplate: "https://{domain}/{user}/{project}/issues",
      gittemplate: "git://{auth@}{domain}/{user}/{project}.git{#committish}",
      tarballtemplate: "https://codeload.{domain}/{user}/{project}/tar.gz/{committish}"
    },
    bitbucket: {
      protocols: ["git+ssh", "git+https", "ssh", "https"],
      domain: "bitbucket.org",
      treepath: "src",
      tarballtemplate: "https://{domain}/{user}/{project}/get/{committish}.tar.gz"
    },
    gitlab: {
      protocols: ["git+ssh", "git+https", "ssh", "https"],
      domain: "gitlab.com",
      treepath: "tree",
      bugstemplate: "https://{domain}/{user}/{project}/issues",
      httpstemplate: "git+https://{auth@}{domain}/{user}/{projectPath}.git{#committish}",
      tarballtemplate: "https://{domain}/{user}/{project}/repository/archive.tar.gz?ref={committish}",
      pathmatch: /^[/]([^/]+)[/]((?!.*(\/-\/|\/repository\/archive\.tar\.gz\?=.*|\/repository\/[^/]+\/archive.tar.gz$)).*?)(?:[.]git|[/])?$/
    },
    gist: {
      protocols: ["git", "git+ssh", "git+https", "ssh", "https"],
      domain: "gist.github.com",
      pathmatch: /^[/](?:([^/]+)[/])?([a-z0-9]{32,})(?:[.]git)?$/,
      filetemplate: "https://gist.githubusercontent.com/{user}/{project}/raw{/committish}/{path}",
      bugstemplate: "https://{domain}/{project}",
      gittemplate: "git://{domain}/{project}.git{#committish}",
      sshtemplate: "git@{domain}:/{project}.git{#committish}",
      sshurltemplate: "git+ssh://git@{domain}/{project}.git{#committish}",
      browsetemplate: "https://{domain}/{project}{/committish}",
      browsefiletemplate: "https://{domain}/{project}{/committish}{#path}",
      docstemplate: "https://{domain}/{project}{/committish}",
      httpstemplate: "git+https://{domain}/{project}.git{#committish}",
      shortcuttemplate: "{type}:{project}{#committish}",
      pathtemplate: "{project}{#committish}",
      tarballtemplate: "https://codeload.github.com/gist/{project}/tar.gz/{committish}",
      hashformat: function(fragment) {
        return "file-" + formatHashFragment(fragment);
      }
    }
  };
  var gitHostDefaults = {
    sshtemplate: "git@{domain}:{user}/{project}.git{#committish}",
    sshurltemplate: "git+ssh://git@{domain}/{user}/{project}.git{#committish}",
    browsetemplate: "https://{domain}/{user}/{project}{/tree/committish}",
    browsefiletemplate: "https://{domain}/{user}/{project}/{treepath}/{committish}/{path}{#fragment}",
    docstemplate: "https://{domain}/{user}/{project}{/tree/committish}#readme",
    httpstemplate: "git+https://{auth@}{domain}/{user}/{project}.git{#committish}",
    filetemplate: "https://{domain}/{user}/{project}/raw/{committish}/{path}",
    shortcuttemplate: "{type}:{user}/{project}{#committish}",
    pathtemplate: "{user}/{project}{#committish}",
    pathmatch: /^[/]([^/]+)[/]([^/]+?)(?:[.]git|[/])?$/,
    hashformat: formatHashFragment
  };
  Object.keys(gitHosts).forEach(function(name) {
    Object.keys(gitHostDefaults).forEach(function(key) {
      if (gitHosts[name][key])
        return;
      gitHosts[name][key] = gitHostDefaults[key];
    });
    gitHosts[name].protocols_re = RegExp("^(" + gitHosts[name].protocols.map(function(protocol) {
      return protocol.replace(/([\\+*{}()[\]$^|])/g, "\\$1");
    }).join("|") + "):$");
  });
  function formatHashFragment(fragment) {
    return fragment.toLowerCase().replace(/^\W+|\/|\W+$/g, "").replace(/\W+/g, "-");
  }
});

// ../../node_modules/.pnpm/hosted-git-info@2.8.8/node_modules/hosted-git-info/git-host.js
var require_git_host = __commonJS((exports2, module2) => {
  "use strict";
  var gitHosts = require_git_host_info();
  var extend = Object.assign || function _extend(target, source) {
    if (source === null || typeof source !== "object")
      return target;
    var keys = Object.keys(source);
    var i = keys.length;
    while (i--) {
      target[keys[i]] = source[keys[i]];
    }
    return target;
  };
  module2.exports = GitHost;
  function GitHost(type, user, auth, project, committish, defaultRepresentation, opts) {
    var gitHostInfo = this;
    gitHostInfo.type = type;
    Object.keys(gitHosts[type]).forEach(function(key) {
      gitHostInfo[key] = gitHosts[type][key];
    });
    gitHostInfo.user = user;
    gitHostInfo.auth = auth;
    gitHostInfo.project = project;
    gitHostInfo.committish = committish;
    gitHostInfo.default = defaultRepresentation;
    gitHostInfo.opts = opts || {};
  }
  GitHost.prototype.hash = function() {
    return this.committish ? "#" + this.committish : "";
  };
  GitHost.prototype._fill = function(template, opts) {
    if (!template)
      return;
    var vars = extend({}, opts);
    vars.path = vars.path ? vars.path.replace(/^[/]+/g, "") : "";
    opts = extend(extend({}, this.opts), opts);
    var self = this;
    Object.keys(this).forEach(function(key) {
      if (self[key] != null && vars[key] == null)
        vars[key] = self[key];
    });
    var rawAuth = vars.auth;
    var rawcommittish = vars.committish;
    var rawFragment = vars.fragment;
    var rawPath = vars.path;
    var rawProject = vars.project;
    Object.keys(vars).forEach(function(key) {
      var value = vars[key];
      if ((key === "path" || key === "project") && typeof value === "string") {
        vars[key] = value.split("/").map(function(pathComponent) {
          return encodeURIComponent(pathComponent);
        }).join("/");
      } else {
        vars[key] = encodeURIComponent(value);
      }
    });
    vars["auth@"] = rawAuth ? rawAuth + "@" : "";
    vars["#fragment"] = rawFragment ? "#" + this.hashformat(rawFragment) : "";
    vars.fragment = vars.fragment ? vars.fragment : "";
    vars["#path"] = rawPath ? "#" + this.hashformat(rawPath) : "";
    vars["/path"] = vars.path ? "/" + vars.path : "";
    vars.projectPath = rawProject.split("/").map(encodeURIComponent).join("/");
    if (opts.noCommittish) {
      vars["#committish"] = "";
      vars["/tree/committish"] = "";
      vars["/committish"] = "";
      vars.committish = "";
    } else {
      vars["#committish"] = rawcommittish ? "#" + rawcommittish : "";
      vars["/tree/committish"] = vars.committish ? "/" + vars.treepath + "/" + vars.committish : "";
      vars["/committish"] = vars.committish ? "/" + vars.committish : "";
      vars.committish = vars.committish || "master";
    }
    var res = template;
    Object.keys(vars).forEach(function(key) {
      res = res.replace(new RegExp("[{]" + key + "[}]", "g"), vars[key]);
    });
    if (opts.noGitPlus) {
      return res.replace(/^git[+]/, "");
    } else {
      return res;
    }
  };
  GitHost.prototype.ssh = function(opts) {
    return this._fill(this.sshtemplate, opts);
  };
  GitHost.prototype.sshurl = function(opts) {
    return this._fill(this.sshurltemplate, opts);
  };
  GitHost.prototype.browse = function(P, F, opts) {
    if (typeof P === "string") {
      if (typeof F !== "string") {
        opts = F;
        F = null;
      }
      return this._fill(this.browsefiletemplate, extend({
        fragment: F,
        path: P
      }, opts));
    } else {
      return this._fill(this.browsetemplate, P);
    }
  };
  GitHost.prototype.docs = function(opts) {
    return this._fill(this.docstemplate, opts);
  };
  GitHost.prototype.bugs = function(opts) {
    return this._fill(this.bugstemplate, opts);
  };
  GitHost.prototype.https = function(opts) {
    return this._fill(this.httpstemplate, opts);
  };
  GitHost.prototype.git = function(opts) {
    return this._fill(this.gittemplate, opts);
  };
  GitHost.prototype.shortcut = function(opts) {
    return this._fill(this.shortcuttemplate, opts);
  };
  GitHost.prototype.path = function(opts) {
    return this._fill(this.pathtemplate, opts);
  };
  GitHost.prototype.tarball = function(opts_) {
    var opts = extend({}, opts_, {noCommittish: false});
    return this._fill(this.tarballtemplate, opts);
  };
  GitHost.prototype.file = function(P, opts) {
    return this._fill(this.filetemplate, extend({path: P}, opts));
  };
  GitHost.prototype.getDefaultRepresentation = function() {
    return this.default;
  };
  GitHost.prototype.toString = function(opts) {
    if (this.default && typeof this[this.default] === "function")
      return this[this.default](opts);
    return this.sshurl(opts);
  };
});

// ../../node_modules/.pnpm/hosted-git-info@2.8.8/node_modules/hosted-git-info/index.js
var require_hosted_git_info = __commonJS((exports2, module2) => {
  "use strict";
  var url = require("url");
  var gitHosts = require_git_host_info();
  var GitHost = module2.exports = require_git_host();
  var protocolToRepresentationMap = {
    "git+ssh:": "sshurl",
    "git+https:": "https",
    "ssh:": "sshurl",
    "git:": "git"
  };
  function protocolToRepresentation(protocol) {
    return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);
  }
  var authProtocols = {
    "git:": true,
    "https:": true,
    "git+https:": true,
    "http:": true,
    "git+http:": true
  };
  var cache = {};
  module2.exports.fromUrl = function(giturl, opts) {
    if (typeof giturl !== "string")
      return;
    var key = giturl + JSON.stringify(opts || {});
    if (!(key in cache)) {
      cache[key] = fromUrl(giturl, opts);
    }
    return cache[key];
  };
  function fromUrl(giturl, opts) {
    if (giturl == null || giturl === "")
      return;
    var url2 = fixupUnqualifiedGist(isGitHubShorthand(giturl) ? "github:" + giturl : giturl);
    var parsed = parseGitUrl(url2);
    var shortcutMatch = url2.match(new RegExp("^([^:]+):(?:(?:[^@:]+(?:[^@]+)?@)?([^/]*))[/](.+?)(?:[.]git)?($|#)"));
    var matches = Object.keys(gitHosts).map(function(gitHostName) {
      try {
        var gitHostInfo = gitHosts[gitHostName];
        var auth = null;
        if (parsed.auth && authProtocols[parsed.protocol]) {
          auth = parsed.auth;
        }
        var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null;
        var user = null;
        var project = null;
        var defaultRepresentation = null;
        if (shortcutMatch && shortcutMatch[1] === gitHostName) {
          user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2]);
          project = decodeURIComponent(shortcutMatch[3]);
          defaultRepresentation = "shortcut";
        } else {
          if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, "") !== gitHostInfo.domain)
            return;
          if (!gitHostInfo.protocols_re.test(parsed.protocol))
            return;
          if (!parsed.path)
            return;
          var pathmatch = gitHostInfo.pathmatch;
          var matched = parsed.path.match(pathmatch);
          if (!matched)
            return;
          if (matched[1] !== null && matched[1] !== void 0) {
            user = decodeURIComponent(matched[1].replace(/^:/, ""));
          }
          project = decodeURIComponent(matched[2]);
          defaultRepresentation = protocolToRepresentation(parsed.protocol);
        }
        return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);
      } catch (ex) {
        if (ex instanceof URIError) {
        } else
          throw ex;
      }
    }).filter(function(gitHostInfo) {
      return gitHostInfo;
    });
    if (matches.length !== 1)
      return;
    return matches[0];
  }
  function isGitHubShorthand(arg) {
    return /^[^:@%/\s.-][^:@%/\s]*[/][^:@\s/%]+(?:#.*)?$/.test(arg);
  }
  function fixupUnqualifiedGist(giturl) {
    var parsed = url.parse(giturl);
    if (parsed.protocol === "gist:" && parsed.host && !parsed.path) {
      return parsed.protocol + "/" + parsed.host;
    } else {
      return giturl;
    }
  }
  function parseGitUrl(giturl) {
    var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/);
    if (!matched) {
      var legacy = url.parse(giturl);
      if (legacy.auth && typeof url.URL === "function") {
        var authmatch = giturl.match(/[^@]+@[^:/]+/);
        if (authmatch) {
          var whatwg = new url.URL(authmatch[0]);
          legacy.auth = whatwg.username || "";
          if (whatwg.password)
            legacy.auth += ":" + whatwg.password;
        }
      }
      return legacy;
    }
    return {
      protocol: "git+ssh:",
      slashes: true,
      auth: matched[1],
      host: matched[2],
      port: null,
      hostname: matched[2],
      hash: matched[4],
      search: null,
      query: null,
      pathname: "/" + matched[3],
      path: "/" + matched[3],
      href: "git+ssh://" + matched[1] + "@" + matched[2] + "/" + matched[3] + (matched[4] || "")
    };
  }
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/internal/constants.js
var require_constants = __commonJS((exports2, module2) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  module2.exports = {
    SEMVER_SPEC_VERSION,
    MAX_LENGTH,
    MAX_SAFE_INTEGER,
    MAX_SAFE_COMPONENT_LENGTH
  };
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports2, module2) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  module2.exports = debug;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/internal/re.js
var require_re = __commonJS((exports2, module2) => {
  var {MAX_SAFE_COMPONENT_LENGTH} = require_constants();
  var debug = require_debug();
  exports2 = module2.exports = {};
  var re = exports2.re = [];
  var src = exports2.src = [];
  var t = exports2.t = {};
  var R = 0;
  var createToken = (name, value, isGlobal) => {
    const index = R++;
    debug(index, value);
    t[name] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports2.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports2.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports2, module2) => {
  var opts = ["includePrerelease", "loose", "rtl"];
  var parseOptions = (options) => !options ? {} : typeof options !== "object" ? {loose: true} : opts.filter((k) => options[k]).reduce((options2, k) => {
    options2[k] = true;
    return options2;
  }, {});
  module2.exports = parseOptions;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports2, module2) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module2.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports2, module2) => {
  var debug = require_debug();
  var {MAX_LENGTH, MAX_SAFE_INTEGER} = require_constants();
  var {re, t} = require_re();
  var parseOptions = require_parse_options();
  var {compareIdentifiers} = require_identifiers();
  var SemVer = class {
    constructor(version, options) {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("prerelease compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    inc(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.format();
      this.raw = this.version;
      return this;
    }
  };
  module2.exports = SemVer;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/parse.js
var require_parse = __commonJS((exports2, module2) => {
  var {MAX_LENGTH} = require_constants();
  var {re, t} = require_re();
  var SemVer = require_semver();
  var parseOptions = require_parse_options();
  var parse = (version, options) => {
    options = parseOptions(options);
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    const r = options.loose ? re[t.LOOSE] : re[t.FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  };
  module2.exports = parse;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports2, module2) => {
  var parse = require_parse();
  var valid = (version, options) => {
    const v = parse(version, options);
    return v ? v.version : null;
  };
  module2.exports = valid;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports2, module2) => {
  var parse = require_parse();
  var clean = (version, options) => {
    const s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  module2.exports = clean;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var inc = (version, release, options, identifier) => {
    if (typeof options === "string") {
      identifier = options;
      options = void 0;
    }
    try {
      return new SemVer(version, options).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  };
  module2.exports = inc;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module2.exports = compare;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var eq = (a, b, loose) => compare(a, b, loose) === 0;
  module2.exports = eq;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports2, module2) => {
  var parse = require_parse();
  var eq = require_eq();
  var diff = (version1, version2) => {
    if (eq(version1, version2)) {
      return null;
    } else {
      const v1 = parse(version1);
      const v2 = parse(version2);
      const hasPre = v1.prerelease.length || v2.prerelease.length;
      const prefix = hasPre ? "pre" : "";
      const defaultResult = hasPre ? "prerelease" : "";
      for (const key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  };
  module2.exports = diff;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/major.js
var require_major = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var major = (a, loose) => new SemVer(a, loose).major;
  module2.exports = major;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var minor = (a, loose) => new SemVer(a, loose).minor;
  module2.exports = minor;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var patch = (a, loose) => new SemVer(a, loose).patch;
  module2.exports = patch;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports2, module2) => {
  var parse = require_parse();
  var prerelease = (version, options) => {
    const parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module2.exports = prerelease;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var rcompare = (a, b, loose) => compare(b, a, loose);
  module2.exports = rcompare;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var compareLoose = (a, b) => compare(a, b, true);
  module2.exports = compareLoose;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module2.exports = compareBuild;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports2, module2) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  module2.exports = sort;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports2, module2) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  module2.exports = rsort;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var gt = (a, b, loose) => compare(a, b, loose) > 0;
  module2.exports = gt;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var lt = (a, b, loose) => compare(a, b, loose) < 0;
  module2.exports = lt;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var neq = (a, b, loose) => compare(a, b, loose) !== 0;
  module2.exports = neq;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var gte = (a, b, loose) => compare(a, b, loose) >= 0;
  module2.exports = gte;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var lte = (a, b, loose) => compare(a, b, loose) <= 0;
  module2.exports = lte;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports2, module2) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module2.exports = cmp;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var parse = require_parse();
  var {re, t} = require_re();
  var coerce = (version, options) => {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version.match(re[t.COERCE]);
    } else {
      let next;
      while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re[t.COERCERTL].lastIndex = -1;
    }
    if (match === null)
      return null;
    return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
  };
  module2.exports = coerce;
});

// ../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// ../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  function Yallist(list) {
    var self = this;
    if (!(self instanceof Yallist)) {
      self = new Yallist();
    }
    self.tail = null;
    self.head = null;
    self.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length; i < l; i++) {
        self.push(arguments[i]);
      }
    }
    return self;
  }
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return void 0;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return void 0;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.head; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.tail; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0; walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0; i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  function insert(self, node, value) {
    var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
    if (inserted.next === null) {
      self.tail = inserted;
    }
    if (inserted.prev === null) {
      self.head = inserted;
    }
    self.length++;
    return inserted;
  }
  function push(self, item) {
    self.tail = new Node(item, self.tail, null, self);
    if (!self.head) {
      self.head = self.tail;
    }
    self.length++;
  }
  function unshift(self, item) {
    self.head = new Node(item, null, self.head, self);
    if (!self.tail) {
      self.tail = self.head;
    }
    self.length++;
  }
  function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// ../../node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports2, module2) => {
  "use strict";
  var Yallist = require_yallist();
  var MAX = Symbol("max");
  var LENGTH = Symbol("length");
  var LENGTH_CALCULATOR = Symbol("lengthCalculator");
  var ALLOW_STALE = Symbol("allowStale");
  var MAX_AGE = Symbol("maxAge");
  var DISPOSE = Symbol("dispose");
  var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  var LRU_LIST = Symbol("lruList");
  var CACHE = Symbol("cache");
  var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  var naiveLength = () => 1;
  var LRUCache = class {
    constructor(options) {
      if (typeof options === "number")
        options = {max: options};
      if (!options)
        options = {};
      if (options.max && (typeof options.max !== "number" || options.max < 0))
        throw new TypeError("max must be a non-negative number");
      const max = this[MAX] = options.max || Infinity;
      const lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail; walker !== null; ) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head; walker !== null; ) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k) => k.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k) => k.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = new Map();
      this[LRU_LIST] = new Yallist();
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter((h) => h);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        const node = this[CACHE].get(key);
        const item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      const hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key, value);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key) {
      if (!this[CACHE].has(key))
        return false;
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
    get(key) {
      return get(this, key, true);
    }
    peek(key) {
      return get(this, key, false);
    }
    pop() {
      const node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    }
    del(key) {
      del(this, this[CACHE].get(key));
    }
    load(arr) {
      this.reset();
      const now = Date.now();
      for (let l = arr.length - 1; l >= 0; l--) {
        const hit = arr[l];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value, key) => get(this, key, false));
    }
  };
  var get = (self, key, doUse) => {
    const node = self[CACHE].get(key);
    if (node) {
      const hit = node.value;
      if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE])
          return void 0;
      } else {
        if (doUse) {
          if (self[UPDATE_AGE_ON_GET])
            node.value.now = Date.now();
          self[LRU_LIST].unshiftNode(node);
        }
      }
      return hit.value;
    }
  };
  var isStale = (self, hit) => {
    if (!hit || !hit.maxAge && !self[MAX_AGE])
      return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
  };
  var trim = (self) => {
    if (self[LENGTH] > self[MAX]) {
      for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
        const prev = walker.prev;
        del(self, walker);
        walker = prev;
      }
    }
  };
  var del = (self, node) => {
    if (node) {
      const hit = node.value;
      if (self[DISPOSE])
        self[DISPOSE](hit.key, hit.value);
      self[LENGTH] -= hit.length;
      self[CACHE].delete(hit.key);
      self[LRU_LIST].removeNode(node);
    }
  };
  var Entry = class {
    constructor(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  };
  var forEachStep = (self, fn, node, thisp) => {
    let hit = node.value;
    if (isStale(self, hit)) {
      del(self, node);
      if (!self[ALLOW_STALE])
        hit = void 0;
    }
    if (hit)
      fn.call(thisp, hit.value, hit.key, self);
  };
  module2.exports = LRUCache;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/classes/range.js
var require_range = __commonJS((exports2, module2) => {
  var Range = class {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${range}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0)
          this.set = [first];
        else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      range = range.trim();
      const memoOpts = Object.keys(this.options).join(",");
      const memoKey = `parseRange:${memoOpts}:${range}`;
      const cached = cache.get(memoKey);
      if (cached)
        return cached;
      const loose = this.options.loose;
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[t.COMPARATORTRIM]);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
      const l = rangeList.length;
      const rangeMap = new Map();
      for (const comp of rangeList) {
        if (isNullSet(comp))
          return [comp];
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has(""))
        rangeMap.delete("");
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  };
  module2.exports = Range;
  var LRU = require_lru_cache();
  var cache = new LRU({max: 1e3});
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver();
  var {
    re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
    return replaceTilde(comp2, options);
  }).join(" ");
  var replaceTilde = (comp, options) => {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
    return replaceCaret(comp2, options);
  }).join(" ");
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((comp2) => {
      return replaceXRange(comp2, options);
    }).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<")
          pr = "-0";
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set, version, options) => {
    for (let i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports2, module2) => {
  var ANY = Symbol("SemVer ANY");
  var Comparator = class {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      const sameSemVer = this.semver.version === comp.semver.version;
      const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
      const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    }
  };
  module2.exports = Comparator;
  var parseOptions = require_parse_options();
  var {re, t} = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver();
  var Range = require_range();
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports2, module2) => {
  var Range = require_range();
  var satisfies = (version, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  };
  module2.exports = satisfies;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports2, module2) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  module2.exports = toComparators;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Range = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module2.exports = maxSatisfying;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Range = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module2.exports = minSatisfying;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0; i < range.set.length; ++i) {
      const comparators = range.set[i];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin)))
        minver = setMin;
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module2.exports = minVersion;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports2, module2) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module2.exports = validRange;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var {ANY} = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version, range, hilo, options) => {
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (let i = 0; i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module2.exports = outside;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports2, module2) => {
  var outside = require_outside();
  var gtr = (version, range, options) => outside(version, range, ">", options);
  module2.exports = gtr;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports2, module2) => {
  var outside = require_outside();
  var ltr = (version, range, options) => outside(version, range, "<", options);
  module2.exports = ltr;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports2, module2) => {
  var Range = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  };
  module2.exports = intersects;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports2, module2) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module2.exports = (versions, range, options) => {
    const set = [];
    let min = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version of v) {
      const included = satisfies(version, range, options);
      if (included) {
        prev = version;
        if (!min)
          min = version;
      } else {
        if (prev) {
          set.push([min, prev]);
        }
        prev = null;
        min = null;
      }
    }
    if (min)
      set.push([min, null]);
    const ranges = [];
    for (const [min2, max] of set) {
      if (min2 === max)
        ranges.push(min2);
      else if (!max && min2 === v[0])
        ranges.push("*");
      else if (!max)
        ranges.push(`>=${min2}`);
      else if (min2 === v[0])
        ranges.push(`<=${max}`);
      else
        ranges.push(`${min2} - ${max}`);
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports2, module2) => {
  var Range = require_range();
  var {ANY} = require_comparator();
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options) => {
    if (sub === dom)
      return true;
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub)
            continue OUTER;
        }
        if (sawNonNull)
          return false;
      }
    return true;
  };
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom)
      return true;
    if (sub.length === 1 && sub[0].semver === ANY)
      return dom.length === 1 && dom[0].semver === ANY;
    const eqSet = new Set();
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=")
        gt = higherGT(gt, c, options);
      else if (c.operator === "<" || c.operator === "<=")
        lt = lowerLT(lt, c, options);
      else
        eqSet.add(c.semver);
    }
    if (eqSet.size > 1)
      return null;
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0)
        return null;
      else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
        return null;
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options))
        return null;
      if (lt && !satisfies(eq, String(lt), options))
        return null;
      for (const c of dom) {
        if (!satisfies(eq, String(c), options))
          return false;
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt)
            return false;
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
          return false;
      }
      if (lt) {
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt)
            return false;
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
          return false;
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0)
        return false;
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0)
      return false;
    if (lt && hasDomGT && !gt && gtltComp !== 0)
      return false;
    return true;
  };
  var higherGT = (a, b, options) => {
    if (!a)
      return b;
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  var lowerLT = (a, b, options) => {
    if (!a)
      return b;
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  module2.exports = subset;
});

// ../../node_modules/.pnpm/semver@7.3.4/node_modules/semver/index.js
var require_semver2 = __commonJS((exports2, module2) => {
  var internalRe = require_re();
  module2.exports = {
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
    SemVer: require_semver(),
    compareIdentifiers: require_identifiers().compareIdentifiers,
    rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
    parse: require_parse(),
    valid: require_valid(),
    clean: require_clean(),
    inc: require_inc(),
    diff: require_diff(),
    major: require_major(),
    minor: require_minor(),
    patch: require_patch(),
    prerelease: require_prerelease(),
    compare: require_compare(),
    rcompare: require_rcompare(),
    compareLoose: require_compare_loose(),
    compareBuild: require_compare_build(),
    sort: require_sort(),
    rsort: require_rsort(),
    gt: require_gt(),
    lt: require_lt(),
    eq: require_eq(),
    neq: require_neq(),
    gte: require_gte(),
    lte: require_lte(),
    cmp: require_cmp(),
    coerce: require_coerce(),
    Comparator: require_comparator(),
    Range: require_range(),
    satisfies: require_satisfies(),
    toComparators: require_to_comparators(),
    maxSatisfying: require_max_satisfying(),
    minSatisfying: require_min_satisfying(),
    minVersion: require_min_version(),
    validRange: require_valid2(),
    outside: require_outside(),
    gtr: require_gtr(),
    ltr: require_ltr(),
    intersects: require_intersects(),
    simplifyRange: require_simplify(),
    subset: require_subset()
  };
});

// ../../node_modules/.pnpm/@zkochan#npm-package-arg@1.0.2/node_modules/@zkochan/npm-package-arg/npa.js
var require_npa = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = npa;
  module2.exports.resolve = resolve;
  module2.exports.Result = Result;
  var url;
  var HostedGit;
  var semver;
  var path2;
  var validatePackageName;
  var os;
  var isWindows = process.platform === "win32" || global.FAKE_WINDOWS;
  var hasSlashes = isWindows ? /\\|[/]/ : /[/]/;
  var isURL = /^(?:git[+])?[a-z]+:/i;
  var isFilename = /[.](?:tgz|tar.gz|tar)$/i;
  function npa(arg, where) {
    let name;
    let spec;
    if (typeof arg === "object") {
      if (arg instanceof Result && (!where || where === arg.where)) {
        return arg;
      } else if (arg.name && arg.rawSpec) {
        return npa.resolve(arg.name, arg.rawSpec, where || arg.where);
      } else {
        return npa(arg.raw, where || arg.where);
      }
    }
    const nameEndsAt = arg[0] === "@" ? arg.slice(1).indexOf("@") + 1 : arg.indexOf("@");
    const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg;
    if (isURL.test(arg)) {
      spec = arg;
    } else if (namePart[0] !== "@" && (hasSlashes.test(namePart) || isFilename.test(namePart))) {
      spec = arg;
    } else if (nameEndsAt > 0) {
      name = namePart;
      spec = arg.slice(nameEndsAt + 1);
    } else {
      if (!validatePackageName)
        validatePackageName = require_validate_npm_package_name();
      const valid = validatePackageName(arg);
      if (valid.validForOldPackages) {
        name = arg;
      } else {
        spec = arg;
      }
    }
    return resolve(name, spec, where, arg);
  }
  var isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/;
  function resolve(name, spec, where, arg) {
    const res = new Result({
      raw: arg,
      name,
      rawSpec: spec,
      fromArgument: arg != null
    });
    if (name)
      res.setName(name);
    if (spec && (isFilespec.test(spec) || /^file:/i.test(spec))) {
      return fromFile(res, where);
    }
    if (spec && spec.startsWith("npm:")) {
      return Object.assign(npa(spec.substr(4), where), {
        alias: name,
        raw: res.raw,
        rawSpec: res.rawSpec
      });
    }
    if (!HostedGit)
      HostedGit = require_hosted_git_info();
    const hosted = HostedGit.fromUrl(spec, {noGitPlus: true, noCommittish: true});
    if (hosted) {
      return fromHostedGit(res, hosted);
    } else if (spec && isURL.test(spec)) {
      return fromURL(res);
    } else if (spec && (hasSlashes.test(spec) || isFilename.test(spec))) {
      return fromFile(res, where);
    } else {
      return fromRegistry(res);
    }
  }
  function invalidPackageName(name, valid) {
    const err = new Error(`Invalid package name "${name}": ${valid.errors.join("; ")}`);
    err.code = "EINVALIDPACKAGENAME";
    return err;
  }
  function invalidTagName(name) {
    const err = new Error(`Invalid tag name "${name}": Tags may not have any characters that encodeURIComponent encodes.`);
    err.code = "EINVALIDTAGNAME";
    return err;
  }
  function Result(opts) {
    this.type = opts.type;
    this.registry = opts.registry;
    this.where = opts.where;
    if (opts.raw == null) {
      this.raw = opts.name ? opts.name + "@" + opts.rawSpec : opts.rawSpec;
    } else {
      this.raw = opts.raw;
    }
    this.name = void 0;
    this.escapedName = void 0;
    this.scope = void 0;
    this.rawSpec = opts.rawSpec == null ? "" : opts.rawSpec;
    this.saveSpec = opts.saveSpec;
    this.fetchSpec = opts.fetchSpec;
    if (opts.name)
      this.setName(opts.name);
    this.gitRange = opts.gitRange;
    this.gitCommittish = opts.gitCommittish;
    this.hosted = opts.hosted;
  }
  Result.prototype = {};
  Result.prototype.setName = function(name) {
    if (!validatePackageName)
      validatePackageName = require_validate_npm_package_name();
    const valid = validatePackageName(name);
    if (!valid.validForOldPackages) {
      throw invalidPackageName(name, valid);
    }
    this.name = name;
    this.scope = name[0] === "@" ? name.slice(0, name.indexOf("/")) : void 0;
    this.escapedName = name.replace("/", "%2f");
    return this;
  };
  Result.prototype.toString = function() {
    const full = [];
    if (this.name != null && this.name !== "")
      full.push(this.name);
    const spec = this.saveSpec || this.fetchSpec || this.rawSpec;
    if (spec != null && spec !== "")
      full.push(spec);
    return full.length ? full.join("@") : this.raw;
  };
  Result.prototype.toJSON = function() {
    const result = Object.assign({}, this);
    delete result.hosted;
    return result;
  };
  function setGitCommittish(res, committish) {
    if (committish != null && committish.length >= 7 && committish.slice(0, 7) === "semver:") {
      res.gitRange = decodeURIComponent(committish.slice(7));
      res.gitCommittish = null;
    } else {
      res.gitCommittish = committish === "" ? null : committish;
    }
    return res;
  }
  var isAbsolutePath = /^[/]|^[A-Za-z]:/;
  function resolvePath(where, spec) {
    if (isAbsolutePath.test(spec))
      return spec;
    if (!path2)
      path2 = require("path");
    return path2.resolve(where, spec);
  }
  function isAbsolute(dir) {
    if (dir[0] === "/")
      return true;
    if (/^[A-Za-z]:/.test(dir))
      return true;
    return false;
  }
  function fromFile(res, where) {
    if (!where)
      where = process.cwd();
    res.type = isFilename.test(res.rawSpec) ? "file" : "directory";
    res.where = where;
    const spec = res.rawSpec.replace(/\\/g, "/").replace(/^file:[/]*([A-Za-z]:)/, "$1").replace(/^file:(?:[/]*([~./]))?/, "$1");
    if (/^~[/]/.test(spec)) {
      if (!os)
        os = require("os");
      res.fetchSpec = resolvePath(os.homedir(), spec.slice(2));
      res.saveSpec = "file:" + spec;
    } else {
      res.fetchSpec = resolvePath(where, spec);
      if (isAbsolute(spec)) {
        res.saveSpec = "file:" + spec;
      } else {
        if (!path2)
          path2 = require("path");
        res.saveSpec = "file:" + path2.relative(where, res.fetchSpec);
      }
    }
    return res;
  }
  function fromHostedGit(res, hosted) {
    res.type = "git";
    res.hosted = hosted;
    res.saveSpec = hosted.toString({noGitPlus: false, noCommittish: false});
    res.fetchSpec = hosted.getDefaultRepresentation() === "shortcut" ? null : hosted.toString();
    return setGitCommittish(res, hosted.committish);
  }
  function unsupportedURLType(protocol, spec) {
    const err = new Error(`Unsupported URL Type "${protocol}": ${spec}`);
    err.code = "EUNSUPPORTEDPROTOCOL";
    return err;
  }
  function matchGitScp(spec) {
    const matched = spec.match(/^git\+ssh:\/\/([^:#]+:[^#]+(?:\.git)?)(?:#(.*))?$/i);
    return matched && !matched[1].match(/:[0-9]+\/?.*$/i) && {
      fetchSpec: matched[1],
      gitCommittish: matched[2] == null ? null : matched[2]
    };
  }
  function fromURL(res) {
    if (!url)
      url = require("url");
    const urlparse = url.parse(res.rawSpec);
    res.saveSpec = res.rawSpec;
    switch (urlparse.protocol) {
      case "git:":
      case "git+http:":
      case "git+https:":
      case "git+rsync:":
      case "git+ftp:":
      case "git+file:":
      case "git+ssh:":
        res.type = "git";
        const match = urlparse.protocol === "git+ssh:" && matchGitScp(res.rawSpec);
        if (match) {
          res.fetchSpec = match.fetchSpec;
          res.gitCommittish = match.gitCommittish;
        } else {
          setGitCommittish(res, urlparse.hash != null ? urlparse.hash.slice(1) : "");
          urlparse.protocol = urlparse.protocol.replace(/^git[+]/, "");
          delete urlparse.hash;
          res.fetchSpec = url.format(urlparse);
        }
        break;
      case "http:":
      case "https:":
        res.type = "remote";
        res.fetchSpec = res.saveSpec;
        break;
      default:
        throw unsupportedURLType(urlparse.protocol, res.rawSpec);
    }
    return res;
  }
  function fromRegistry(res) {
    res.registry = true;
    const spec = res.rawSpec === "" ? "latest" : res.rawSpec;
    res.saveSpec = null;
    res.fetchSpec = spec;
    if (!semver)
      semver = require_semver2();
    const version = semver.valid(spec, true);
    const range = semver.validRange(spec, true);
    if (version) {
      res.type = "version";
    } else if (range) {
      res.type = "range";
    } else {
      if (encodeURIComponent(spec) !== spec) {
        throw invalidTagName(spec);
      }
      res.type = "tag";
    }
    return res;
  }
});

// ../../node_modules/.pnpm/@zkochan#libnpx@11.0.3/node_modules/@zkochan/libnpx/parse-args.js
var require_parse_args = __commonJS((exports2, module2) => {
  "use strict";
  var npa;
  var path2 = require("path");
  module2.exports = parseArgs;
  function parseArgs(argv, defaultNpm) {
    argv = argv || process.argv;
    if (argv.length > 2 && argv[2][0] !== "-") {
      return fastPathArgs(argv, defaultNpm);
    }
    npa = require_npa();
    const parser = yargsParser(argv, defaultNpm);
    const opts = parser.getOptions();
    const bools = new Set(opts.boolean);
    let cmdIndex;
    let hasDashDash;
    for (let i = 2; i < argv.length; i++) {
      const opt = argv[i];
      if (opt === "--") {
        hasDashDash = true;
        break;
      } else if (opt === "--node-arg" || opt === "-n") {
        argv[i] = `${opt}=${argv[i + 1]}`;
        argv.splice(i + 1, 1);
      } else if (opt[0] === "-") {
        if (opt !== "--no-install" && !bools.has(opt.replace(/^--?(no-)?/i, "")) && opt.indexOf("=") === -1) {
          i++;
        }
      } else {
        cmdIndex = i;
        break;
      }
    }
    if (cmdIndex) {
      const parsed = parser.parse(argv.slice(0, cmdIndex));
      const parsedCmd = npa(argv[cmdIndex]);
      parsed.command = parsed.package && parsedCmd.type !== "directory" ? argv[cmdIndex] : guessCmdName(parsedCmd);
      parsed.isLocal = parsedCmd.type === "directory";
      parsed.cmdOpts = argv.slice(cmdIndex + 1);
      if (typeof parsed.package === "string") {
        parsed.package = [parsed.package];
      }
      parsed.packageRequested = !!parsed.package;
      parsed.cmdHadVersion = parsed.package || parsedCmd.type === "directory" ? false : parsedCmd.name !== parsedCmd.raw;
      const pkg = parsed.package || [argv[cmdIndex]];
      parsed.p = parsed.package = pkg.map((p) => npa(p).toString());
      return parsed;
    } else {
      const parsed = parser.parse(argv);
      if (typeof parsed.package === "string") {
        parsed.package = [parsed.package];
      }
      if (parsed.call && parsed.package) {
        parsed.packageRequested = !!parsed.package;
        parsed.cmdHadVersion = false;
        const pkg = parsed.package;
        parsed.p = parsed.package = pkg.map((p) => npa(p).toString());
      } else if (parsed.call && !parsed.package) {
        parsed.packageRequested = false;
        parsed.cmdHadVersion = false;
        parsed.p = parsed.package = [];
      } else if (hasDashDash) {
        const splitCmd = parsed._.slice(2);
        const parsedCmd = npa(splitCmd[0]);
        parsed.command = parsed.package ? splitCmd[0] : guessCmdName(parsedCmd);
        parsed.cmdOpts = splitCmd.slice(1);
        parsed.packageRequested = !!parsed.package;
        parsed.cmdHadVersion = parsed.package ? false : parsedCmd.name !== parsedCmd.raw;
        const pkg = parsed.package || [splitCmd[0]];
        parsed.p = parsed.package = pkg.map((p) => npa(p).toString());
      }
      return parsed;
    }
  }
  function fastPathArgs(argv, defaultNpm) {
    let parsedCmd;
    let pkg;
    if (argv[2].match(/^[a-z0-9_-]+$/i)) {
      parsedCmd = {registry: true, name: argv[2], raw: argv[2]};
      pkg = [`${argv[2]}@latest`];
    } else {
      npa = require_npa();
      parsedCmd = npa(argv[2]);
      if (parsedCmd.type === "directory") {
        pkg = [];
      } else {
        pkg = [parsedCmd.toString()];
      }
    }
    return {
      command: guessCmdName(parsedCmd),
      cmdOpts: argv.slice(3),
      packageRequested: false,
      isLocal: parsedCmd.type === "directory",
      cmdHadVersion: parsedCmd.name !== parsedCmd.raw && parsedCmd.type !== "directory",
      package: pkg,
      p: pkg,
      shell: false,
      noYargs: true,
      npm: defaultNpm || "npm"
    };
  }
  parseArgs.showHelp = () => require_yargs3().showHelp();
  module2.exports._guessCmdName = guessCmdName;
  function guessCmdName(spec) {
    if (typeof spec === "string") {
      if (!npa) {
        npa = require_npa();
      }
      spec = npa(spec);
    }
    if (spec.scope) {
      return spec.name.slice(spec.scope.length + 1);
    } else if (spec.registry) {
      return spec.name;
    } else if (spec.hosted && spec.hosted.project) {
      return spec.hosted.project;
    } else if (spec.type === "git") {
      const match = spec.fetchSpec.match(/([a-z0-9-]+)(?:\.git)?$/i);
      return match[1];
    } else if (spec.type === "directory") {
      return spec.raw;
    } else if (spec.type === "file" || spec.type === "remote") {
      let ext = path2.extname(spec.fetchSpec);
      if (ext === ".gz") {
        ext = path2.extname(path2.basename(spec.fetchSpec, ext)) + ext;
      }
      return path2.basename(spec.fetchSpec, ext).replace(/-\d+\.\d+\.\d+(?:-[a-z0-9.\-+]+)?$/i, "");
    }
    console.error(Y()`Unable to guess a binary name from ${spec.raw}. Please use --package.`);
    return null;
  }
  function yargsParser(argv, defaultNpm) {
    const usage = `
  npx [${Y()`options`}] <${Y()`command`}>[@${Y()`version`}] [${Y()`command-arg`}]...

  npx [${Y()`options`}] [-p|--package <${Y()`package`}>]... <${Y()`command`}> [${Y()`command-arg`}]...

  npx [${Y()`options`}] -c '<${Y()`command-string`}>'

  npx --shell-auto-fallback [${Y()`shell`}]
  `;
    return require_yargs3().usage(Y()`Execute binaries from npm packages.\n${usage}`).option("package", {
      alias: "p",
      type: "string",
      describe: Y()`Package to be installed.`
    }).option("cache", {
      type: "string",
      describe: Y()`Location of the npm cache.`
    }).option("always-spawn", {
      describe: Y()`Always spawn a child process to execute the command.`,
      type: "boolean"
    }).option("no-install", {
      type: "boolean",
      describe: Y()`Skip installation if a package is missing.`
    }).option("userconfig", {
      type: "string",
      describe: Y()`Path to user npmrc.`
    }).option("call", {
      alias: "c",
      type: "string",
      describe: Y()`Execute string as if inside \`npm run-script\`.`
    }).option("shell", {
      alias: "s",
      type: "string",
      describe: Y()`Shell to execute the command with, if any.`,
      default: false
    }).option("shell-auto-fallback", {
      choices: ["", "bash", "fish", "zsh"],
      describe: Y()`Generate shell code to use npx as the "command not found" fallback.`,
      requireArg: false,
      type: "string"
    }).option("ignore-existing", {
      describe: Y()`Ignores existing binaries in $PATH, or in the local project. This forces npx to do a temporary install and use the latest version.`,
      type: "boolean"
    }).option("quiet", {
      alias: "q",
      describe: Y()`Suppress output from npx itself. Subcommands will not be affected.`,
      type: "boolean"
    }).option("npm", {
      describe: Y()`npm binary to use for internal operations.`,
      type: "string",
      default: defaultNpm || "npm"
    }).option("node-arg", {
      alias: "n",
      type: "string",
      describe: Y()`Extra node argument when calling a node binary.`
    }).version().alias("version", "v").help().alias("help", "h").epilogue(Y()`For the full documentation, see the manual page for npx(1).`);
  }
  var _y;
  function Y() {
    if (!_y) {
      _y = require_y();
    }
    return _y;
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
var require_windows = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs = require("fs");
  function checkPathExt(path2, options) {
    var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path2.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path2, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path2, options);
  }
  function isexe(path2, options, cb) {
    fs.stat(path2, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path2, options));
    });
  }
  function sync(path2, options) {
    return checkStat(fs.statSync(path2), path2, options);
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
var require_mode = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs = require("fs");
  function isexe(path2, options, cb) {
    fs.stat(path2, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options));
    });
  }
  function sync(path2, options) {
    return checkStat(fs.statSync(path2), options);
  }
  function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
  }
  function checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
var require_isexe = __commonJS((exports2, module2) => {
  var fs = require("fs");
  var core;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core = require_windows();
  } else {
    core = require_mode();
  }
  module2.exports = isexe;
  isexe.sync = sync;
  function isexe(path2, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path2, options || {}, function(er, is) {
          if (er) {
            reject(er);
          } else {
            resolve(is);
          }
        });
      });
    }
    core(path2, options || {}, function(er, is) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is = false;
        }
      }
      cb(er, is);
    });
  }
  function sync(path2, options) {
    try {
      return core.sync(path2, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// ../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js
var require_which = __commonJS((exports2, module2) => {
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path2 = require("path");
  var COLON = isWindows ? ";" : ":";
  var isexe = require_isexe();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), {code: "ENOENT"});
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows ? pathExtExe.split(colon) : [""];
    if (isWindows) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path2.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, {pathExt: pathExtExe}, (er, is) => {
        if (!er && is) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve(p + ext);
        }
        return resolve(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0; i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path2.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0; j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is = isexe.sync(cur, {pathExt: pathExtExe});
          if (is) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module2.exports = which;
  which.sync = whichSync;
});

// ../../node_modules/.pnpm/@zkochan#libnpx@11.0.3/node_modules/@zkochan/libnpx/auto-fallback.js
var require_auto_fallback = __commonJS((exports2, module2) => {
  "use strict";
  var Y = require_y();
  function mkPosix(opts) {
    return `
command_not_found_${opts.isBash ? "handle" : "handler"}() {
  # Do not run within a pipe
  if test ! -t 1; then
    >&2 echo "${Y`command not found: ${"$1"}`}"
    return 127
  fi
  if which npx > /dev/null; then
    echo "${Y`${"$1"} not found. Trying with npx...`}" >&2
  else
    return 127
  fi
  if ! [[ $1 =~ @ ]]; then
    npx --no-install "$@"
  else
    npx "$@"
  fi
  return $?
}`;
  }
  function mkFish(opts) {
    return `
function __fish_command_not_found_on_interactive --on-event fish_prompt
  functions --erase __fish_command_not_found_handler
  functions --erase __fish_command_not_found_setup

  function __fish_command_not_found_handler --on-event fish_command_not_found
    if which npx > /dev/null
        echo "${Y`${"$argv[1]"} not found. Trying with npx...`}" >&2
    else
        return 127
    end
    if string match -q -r @ $argv[1]
        npx $argv
    else
        npx --no-install $argv
    end
  end

  functions --erase __fish_command_not_found_on_interactive
end`;
  }
  module2.exports = autoFallback;
  function autoFallback(shell, fromEnv, opts) {
    if (shell.includes("bash")) {
      return mkPosix({isBash: true, install: opts.install});
    }
    if (shell.includes("zsh")) {
      return mkPosix({isBash: false, install: opts.install});
    }
    if (shell.includes("fish")) {
      return mkFish(opts);
    }
    if (fromEnv) {
      return autoFallback(fromEnv, null, opts);
    }
    console.error(Y`Only Bash, Zsh, and Fish shells are supported :(`);
  }
});

// ../../node_modules/.pnpm/@zkochan#libnpx@11.0.3/node_modules/@zkochan/libnpx/get-prefix.js
var require_get_prefix = __commonJS((exports2, module2) => {
  "use strict";
  var promisify = require_util().promisify;
  var path2 = require("path");
  var statAsync = promisify(require("fs").stat);
  module2.exports = getPrefix;
  function getPrefix(root) {
    const original = root = path2.resolve(root);
    while (path2.basename(root) === "node_modules") {
      root = path2.dirname(root);
    }
    if (original !== root) {
      return Promise.resolve(root);
    } else {
      return Promise.resolve(getPrefixFromTree(root));
    }
  }
  function getPrefixFromTree(current) {
    if (isRootPath(current, process.platform)) {
      return false;
    } else {
      return Promise.all([
        fileExists(path2.join(current, "package.json")),
        fileExists(path2.join(current, "node_modules"))
      ]).then((args) => {
        const hasPkg = args[0];
        const hasModules = args[1];
        if (hasPkg || hasModules) {
          return current;
        } else {
          return getPrefixFromTree(path2.dirname(current));
        }
      });
    }
  }
  module2.exports._fileExists = fileExists;
  function fileExists(f) {
    return statAsync(f).catch((err) => {
      if (err.code !== "ENOENT") {
        throw err;
      }
    });
  }
  module2.exports._isRootPath = isRootPath;
  function isRootPath(p, platform) {
    return platform === "win32" ? p.match(/^[a-z]+:[/\\]?$/i) : p === "/";
  }
});

// ../../node_modules/.pnpm/dotenv@8.2.0/node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports2, module2) => {
  var fs = require("fs");
  var path2 = require("path");
  function log(message) {
    console.log(`[dotenv][DEBUG] ${message}`);
  }
  var NEWLINE = "\n";
  var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
  var RE_NEWLINES = /\\n/g;
  var NEWLINES_MATCH = /\n|\r|\r\n/;
  function parse(src, options) {
    const debug = Boolean(options && options.debug);
    const obj = {};
    src.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
      const keyValueArr = line.match(RE_INI_KEY_VAL);
      if (keyValueArr != null) {
        const key = keyValueArr[1];
        let val = keyValueArr[2] || "";
        const end = val.length - 1;
        const isDoubleQuoted = val[0] === '"' && val[end] === '"';
        const isSingleQuoted = val[0] === "'" && val[end] === "'";
        if (isSingleQuoted || isDoubleQuoted) {
          val = val.substring(1, end);
          if (isDoubleQuoted) {
            val = val.replace(RE_NEWLINES, NEWLINE);
          }
        } else {
          val = val.trim();
        }
        obj[key] = val;
      } else if (debug) {
        log(`did not match key and value when parsing line ${idx + 1}: ${line}`);
      }
    });
    return obj;
  }
  function config(options) {
    let dotenvPath = path2.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    let debug = false;
    if (options) {
      if (options.path != null) {
        dotenvPath = options.path;
      }
      if (options.encoding != null) {
        encoding = options.encoding;
      }
      if (options.debug != null) {
        debug = true;
      }
    }
    try {
      const parsed = parse(fs.readFileSync(dotenvPath, {encoding}), {debug});
      Object.keys(parsed).forEach(function(key) {
        if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
          process.env[key] = parsed[key];
        } else if (debug) {
          log(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
        }
      });
      return {parsed};
    } catch (e) {
      return {error: e};
    }
  }
  module2.exports.config = config;
  module2.exports.parse = parse;
});

// ../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/old.js
var require_old = __commonJS((exports2) => {
  var pathModule = require("path");
  var isWindows = process.platform === "win32";
  var fs = require("fs");
  var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
  function rethrow() {
    var callback;
    if (DEBUG) {
      var backtrace = new Error();
      callback = debugCallback;
    } else
      callback = missingCallback;
    return callback;
    function debugCallback(err) {
      if (err) {
        backtrace.message = err.message;
        err = backtrace;
        missingCallback(err);
      }
    }
    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation)
          throw err;
        else if (!process.noDeprecation) {
          var msg = "fs: missing callback " + (err.stack || err.message);
          if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
        }
      }
    }
  }
  function maybeCallback(cb) {
    return typeof cb === "function" ? cb : rethrow();
  }
  var normalize = pathModule.normalize;
  if (isWindows) {
    nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  } else {
    nextPartRe = /(.*?)(?:[\/]+|$)/g;
  }
  var nextPartRe;
  if (isWindows) {
    splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  } else {
    splitRootRe = /^[\/]*/;
  }
  var splitRootRe;
  exports2.realpathSync = function realpathSync(p, cache) {
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return cache[p];
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs.lstatSync(base);
        knownHard[base] = true;
      }
    }
    while (pos < p.length) {
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        continue;
      }
      var resolvedLink;
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        resolvedLink = cache[base];
      } else {
        var stat = fs.lstatSync(base);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          continue;
        }
        var linkTarget = null;
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            linkTarget = seenLinks[id];
          }
        }
        if (linkTarget === null) {
          fs.statSync(base);
          linkTarget = fs.readlinkSync(base);
        }
        resolvedLink = pathModule.resolve(previous, linkTarget);
        if (cache)
          cache[base] = resolvedLink;
        if (!isWindows)
          seenLinks[id] = linkTarget;
      }
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
    if (cache)
      cache[original] = p;
    return p;
  };
  exports2.realpath = function realpath(p, cache, cb) {
    if (typeof cb !== "function") {
      cb = maybeCallback(cache);
      cache = null;
    }
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return process.nextTick(cb.bind(null, null, cache[p]));
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs.lstat(base, function(err) {
          if (err)
            return cb(err);
          knownHard[base] = true;
          LOOP();
        });
      } else {
        process.nextTick(LOOP);
      }
    }
    function LOOP() {
      if (pos >= p.length) {
        if (cache)
          cache[original] = p;
        return cb(null, p);
      }
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        return process.nextTick(LOOP);
      }
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        return gotResolvedLink(cache[base]);
      }
      return fs.lstat(base, gotStat);
    }
    function gotStat(err, stat) {
      if (err)
        return cb(err);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache)
          cache[base] = base;
        return process.nextTick(LOOP);
      }
      if (!isWindows) {
        var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          return gotTarget(null, seenLinks[id], base);
        }
      }
      fs.stat(base, function(err2) {
        if (err2)
          return cb(err2);
        fs.readlink(base, function(err3, target) {
          if (!isWindows)
            seenLinks[id] = target;
          gotTarget(err3, target);
        });
      });
    }
    function gotTarget(err, target, base2) {
      if (err)
        return cb(err);
      var resolvedLink = pathModule.resolve(previous, target);
      if (cache)
        cache[base2] = resolvedLink;
      gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
  };
});

// ../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/index.js
var require_fs = __commonJS((exports2, module2) => {
  module2.exports = realpath;
  realpath.realpath = realpath;
  realpath.sync = realpathSync;
  realpath.realpathSync = realpathSync;
  realpath.monkeypatch = monkeypatch;
  realpath.unmonkeypatch = unmonkeypatch;
  var fs = require("fs");
  var origRealpath = fs.realpath;
  var origRealpathSync = fs.realpathSync;
  var version = process.version;
  var ok = /^v[0-5]\./.test(version);
  var old = require_old();
  function newError(er) {
    return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
  }
  function realpath(p, cache, cb) {
    if (ok) {
      return origRealpath(p, cache, cb);
    }
    if (typeof cache === "function") {
      cb = cache;
      cache = null;
    }
    origRealpath(p, cache, function(er, result) {
      if (newError(er)) {
        old.realpath(p, cache, cb);
      } else {
        cb(er, result);
      }
    });
  }
  function realpathSync(p, cache) {
    if (ok) {
      return origRealpathSync(p, cache);
    }
    try {
      return origRealpathSync(p, cache);
    } catch (er) {
      if (newError(er)) {
        return old.realpathSync(p, cache);
      } else {
        throw er;
      }
    }
  }
  function monkeypatch() {
    fs.realpath = realpath;
    fs.realpathSync = realpathSync;
  }
  function unmonkeypatch() {
    fs.realpath = origRealpath;
    fs.realpathSync = origRealpathSync;
  }
});

// ../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js
var require_concat_map = __commonJS((exports2, module2) => {
  module2.exports = function(xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray(x))
        res.push.apply(res, x);
      else
        res.push(x);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
});

// ../../node_modules/.pnpm/balanced-match@1.0.0/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
});

// ../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports2, module2) => {
  var concatMap = require_concat_map();
  var balanced = require_balanced_match();
  module2.exports = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m || /\$$/.test(m.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m.post.length ? expand(m.post, false) : [""];
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap(n, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
});

// ../../node_modules/.pnpm/minimatch@3.0.4/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS((exports2, module2) => {
  module2.exports = minimatch;
  minimatch.Minimatch = Minimatch;
  var path2 = {sep: "/"};
  try {
    path2 = require("path");
  } catch (er) {
  }
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = require_brace_expansion();
  var plTypes = {
    "!": {open: "(?:(?!(?:", close: "))[^/]*?)"},
    "?": {open: "(?:", close: ")?"},
    "+": {open: "(?:", close: ")+"},
    "*": {open: "(?:", close: ")*"},
    "@": {open: "(?:", close: ")"}
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set, c) {
      set[c] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch.filter = filter;
  function filter(pattern, options) {
    options = options || {};
    return function(p, i, list) {
      return minimatch(p, pattern, options);
    };
  }
  function ext(a, b) {
    a = a || {};
    b = b || {};
    var t = {};
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    return t;
  }
  minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return minimatch;
    var orig = minimatch;
    var m = function minimatch2(p, pattern, options) {
      return orig.minimatch(p, pattern, ext(def, options));
    };
    m.Minimatch = function Minimatch2(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };
    return m;
  };
  Minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return Minimatch;
    return minimatch.defaults(def).Minimatch;
  };
  function minimatch(p, pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    if (pattern.trim() === "")
      return p === "";
    return new Minimatch(pattern, options).match(p);
  }
  function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options);
    }
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    pattern = pattern.trim();
    if (path2.sep !== "/") {
      pattern = pattern.split(path2.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    if (this._made)
      return;
    var pattern = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options.debug)
      this.debug = console.error;
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s, si, set2) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate)
      return;
    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    if (typeof pattern === "undefined") {
      throw new TypeError("undefined pattern");
    }
    if (options.nobrace || !pattern.match(/\{.*\}/)) {
      return [pattern];
    }
    return expand(pattern);
  }
  Minimatch.prototype.parse = parse;
  var SUBPARSE = {};
  function parse(pattern, isSub) {
    if (pattern.length > 1024 * 64) {
      throw new TypeError("pattern is too long");
    }
    var options = this.options;
    if (!options.noglobstar && pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    var re = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern, i, re, c);
      if (escaping && reSpecials[c]) {
        re += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        case "/":
          return false;
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1)
              c = "^";
            re += c;
            continue;
          }
          self.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          if (inClass) {
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
          }
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re += "\\";
          }
          re += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case ".":
      case "[":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }
  minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? "i" : "";
    var re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = match;
  function match(f, partial) {
    this.debug("match", f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return true;
    var options = this.options;
    if (path2.sep !== "/") {
      f = f.split(path2.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i;
    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename)
        break;
    }
    for (i = 0; i < set.length; i++) {
      var pattern = set[i];
      var file = f;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options.flipNegate)
      return false;
    return this.negate;
  }
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug("matchOne", {this: this, file, pattern});
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        if (options.nocase) {
          hit = f.toLowerCase() === p.toLowerCase();
        } else {
          hit = f === p;
        }
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      var emptyFileEnd = fi === fl - 1 && file[fi] === "";
      return emptyFileEnd;
    }
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
});

// ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports2, module2) => {
  if (typeof Object.create === "function") {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports2, module2) => {
  try {
    util = require("util");
    if (typeof util.inherits !== "function")
      throw "";
    module2.exports = util.inherits;
  } catch (e) {
    module2.exports = require_inherits_browser();
  }
  var util;
});

// ../../node_modules/.pnpm/path-is-absolute@1.0.1/node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS((exports2, module2) => {
  "use strict";
  function posix(path2) {
    return path2.charAt(0) === "/";
  }
  function win32(path2) {
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var result = splitDeviceRe.exec(path2);
    var device = result[1] || "";
    var isUnc = Boolean(device && device.charAt(1) !== ":");
    return Boolean(result[2] || isUnc);
  }
  module2.exports = process.platform === "win32" ? win32 : posix;
  module2.exports.posix = posix;
  module2.exports.win32 = win32;
});

// ../../node_modules/.pnpm/glob@7.1.6/node_modules/glob/common.js
var require_common = __commonJS((exports2) => {
  exports2.alphasort = alphasort;
  exports2.alphasorti = alphasorti;
  exports2.setopts = setopts;
  exports2.ownProp = ownProp;
  exports2.makeAbs = makeAbs;
  exports2.finish = finish;
  exports2.mark = mark;
  exports2.isIgnored = isIgnored;
  exports2.childrenIgnored = childrenIgnored;
  function ownProp(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
  }
  var path2 = require("path");
  var minimatch = require_minimatch();
  var isAbsolute = require_path_is_absolute();
  var Minimatch = minimatch.Minimatch;
  function alphasorti(a, b) {
    return a.toLowerCase().localeCompare(b.toLowerCase());
  }
  function alphasort(a, b) {
    return a.localeCompare(b);
  }
  function setupIgnores(self, options) {
    self.ignore = options.ignore || [];
    if (!Array.isArray(self.ignore))
      self.ignore = [self.ignore];
    if (self.ignore.length) {
      self.ignore = self.ignore.map(ignoreMap);
    }
  }
  function ignoreMap(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === "/**") {
      var gpattern = pattern.replace(/(\/\*\*)+$/, "");
      gmatcher = new Minimatch(gpattern, {dot: true});
    }
    return {
      matcher: new Minimatch(pattern, {dot: true}),
      gmatcher
    };
  }
  function setopts(self, pattern, options) {
    if (!options)
      options = {};
    if (options.matchBase && pattern.indexOf("/") === -1) {
      if (options.noglobstar) {
        throw new Error("base matching requires globstar");
      }
      pattern = "**/" + pattern;
    }
    self.silent = !!options.silent;
    self.pattern = pattern;
    self.strict = options.strict !== false;
    self.realpath = !!options.realpath;
    self.realpathCache = options.realpathCache || Object.create(null);
    self.follow = !!options.follow;
    self.dot = !!options.dot;
    self.mark = !!options.mark;
    self.nodir = !!options.nodir;
    if (self.nodir)
      self.mark = true;
    self.sync = !!options.sync;
    self.nounique = !!options.nounique;
    self.nonull = !!options.nonull;
    self.nosort = !!options.nosort;
    self.nocase = !!options.nocase;
    self.stat = !!options.stat;
    self.noprocess = !!options.noprocess;
    self.absolute = !!options.absolute;
    self.maxLength = options.maxLength || Infinity;
    self.cache = options.cache || Object.create(null);
    self.statCache = options.statCache || Object.create(null);
    self.symlinks = options.symlinks || Object.create(null);
    setupIgnores(self, options);
    self.changedCwd = false;
    var cwd = process.cwd();
    if (!ownProp(options, "cwd"))
      self.cwd = cwd;
    else {
      self.cwd = path2.resolve(options.cwd);
      self.changedCwd = self.cwd !== cwd;
    }
    self.root = options.root || path2.resolve(self.cwd, "/");
    self.root = path2.resolve(self.root);
    if (process.platform === "win32")
      self.root = self.root.replace(/\\/g, "/");
    self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
    if (process.platform === "win32")
      self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
    self.nomount = !!options.nomount;
    options.nonegate = true;
    options.nocomment = true;
    self.minimatch = new Minimatch(pattern, options);
    self.options = self.minimatch.options;
  }
  function finish(self) {
    var nou = self.nounique;
    var all = nou ? [] : Object.create(null);
    for (var i = 0, l = self.matches.length; i < l; i++) {
      var matches = self.matches[i];
      if (!matches || Object.keys(matches).length === 0) {
        if (self.nonull) {
          var literal = self.minimatch.globSet[i];
          if (nou)
            all.push(literal);
          else
            all[literal] = true;
        }
      } else {
        var m = Object.keys(matches);
        if (nou)
          all.push.apply(all, m);
        else
          m.forEach(function(m2) {
            all[m2] = true;
          });
      }
    }
    if (!nou)
      all = Object.keys(all);
    if (!self.nosort)
      all = all.sort(self.nocase ? alphasorti : alphasort);
    if (self.mark) {
      for (var i = 0; i < all.length; i++) {
        all[i] = self._mark(all[i]);
      }
      if (self.nodir) {
        all = all.filter(function(e) {
          var notDir = !/\/$/.test(e);
          var c = self.cache[e] || self.cache[makeAbs(self, e)];
          if (notDir && c)
            notDir = c !== "DIR" && !Array.isArray(c);
          return notDir;
        });
      }
    }
    if (self.ignore.length)
      all = all.filter(function(m2) {
        return !isIgnored(self, m2);
      });
    self.found = all;
  }
  function mark(self, p) {
    var abs = makeAbs(self, p);
    var c = self.cache[abs];
    var m = p;
    if (c) {
      var isDir = c === "DIR" || Array.isArray(c);
      var slash = p.slice(-1) === "/";
      if (isDir && !slash)
        m += "/";
      else if (!isDir && slash)
        m = m.slice(0, -1);
      if (m !== p) {
        var mabs = makeAbs(self, m);
        self.statCache[mabs] = self.statCache[abs];
        self.cache[mabs] = self.cache[abs];
      }
    }
    return m;
  }
  function makeAbs(self, f) {
    var abs = f;
    if (f.charAt(0) === "/") {
      abs = path2.join(self.root, f);
    } else if (isAbsolute(f) || f === "") {
      abs = f;
    } else if (self.changedCwd) {
      abs = path2.resolve(self.cwd, f);
    } else {
      abs = path2.resolve(f);
    }
    if (process.platform === "win32")
      abs = abs.replace(/\\/g, "/");
    return abs;
  }
  function isIgnored(self, path3) {
    if (!self.ignore.length)
      return false;
    return self.ignore.some(function(item) {
      return item.matcher.match(path3) || !!(item.gmatcher && item.gmatcher.match(path3));
    });
  }
  function childrenIgnored(self, path3) {
    if (!self.ignore.length)
      return false;
    return self.ignore.some(function(item) {
      return !!(item.gmatcher && item.gmatcher.match(path3));
    });
  }
});

// ../../node_modules/.pnpm/glob@7.1.6/node_modules/glob/sync.js
var require_sync = __commonJS((exports2, module2) => {
  module2.exports = globSync;
  globSync.GlobSync = GlobSync;
  var fs = require("fs");
  var rp = require_fs();
  var minimatch = require_minimatch();
  var Minimatch = minimatch.Minimatch;
  var Glob = require_glob().Glob;
  var util = require("util");
  var path2 = require("path");
  var assert = require("assert");
  var isAbsolute = require_path_is_absolute();
  var common = require_common();
  var alphasort = common.alphasort;
  var alphasorti = common.alphasorti;
  var setopts = common.setopts;
  var ownProp = common.ownProp;
  var childrenIgnored = common.childrenIgnored;
  var isIgnored = common.isIgnored;
  function globSync(pattern, options) {
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    return new GlobSync(pattern, options).found;
  }
  function GlobSync(pattern, options) {
    if (!pattern)
      throw new Error("must provide pattern");
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options);
    setopts(this, pattern, options);
    if (this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false);
    }
    this._finish();
  }
  GlobSync.prototype._finish = function() {
    assert(this instanceof GlobSync);
    if (this.realpath) {
      var self = this;
      this.matches.forEach(function(matchset, index) {
        var set = self.matches[index] = Object.create(null);
        for (var p in matchset) {
          try {
            p = self._makeAbs(p);
            var real = rp.realpathSync(p, self.realpathCache);
            set[real] = true;
          } catch (er) {
            if (er.syscall === "stat")
              set[self._makeAbs(p)] = true;
            else
              throw er;
          }
        }
      });
    }
    common.finish(this);
  };
  GlobSync.prototype._process = function(pattern, index, inGlobStar) {
    assert(this instanceof GlobSync);
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return;
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
  };
  GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return;
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix.slice(-1) !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path2.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return;
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix)
        newPattern = [prefix, e];
      else
        newPattern = [e];
      this._process(newPattern.concat(remain), index, inGlobStar);
    }
  };
  GlobSync.prototype._emitMatch = function(index, e) {
    if (isIgnored(this, e))
      return;
    var abs = this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute) {
      e = abs;
    }
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    if (this.stat)
      this._stat(e);
  };
  GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, false);
    var entries;
    var lstat;
    var stat;
    try {
      lstat = fs.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT") {
        return null;
      }
    }
    var isSym = lstat && lstat.isSymbolicLink();
    this.symlinks[abs] = isSym;
    if (!isSym && lstat && !lstat.isDirectory())
      this.cache[abs] = "FILE";
    else
      entries = this._readdir(abs, false);
    return entries;
  };
  GlobSync.prototype._readdir = function(abs, inGlobStar) {
    var entries;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return null;
      if (Array.isArray(c))
        return c;
    }
    try {
      return this._readdirEntries(abs, fs.readdirSync(abs));
    } catch (er) {
      this._readdirError(abs, er);
      return null;
    }
  };
  GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return entries;
  };
  GlobSync.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + " invalid cwd " + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          throw error;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict)
          throw er;
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
  };
  GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false);
    var len = entries.length;
    var isSym = this.symlinks[abs];
    if (isSym && inGlobStar)
      return;
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true);
    }
  };
  GlobSync.prototype._processSimple = function(prefix, index) {
    var exists = this._stat(prefix);
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists)
      return;
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path2.join(this.root, prefix);
      } else {
        prefix = path2.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
  };
  GlobSync.prototype._stat = function(f) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return false;
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return c;
      if (needDir && c === "FILE")
        return false;
    }
    var exists;
    var stat = this.statCache[abs];
    if (!stat) {
      var lstat;
      try {
        lstat = fs.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return false;
        }
      }
      if (lstat && lstat.isSymbolicLink()) {
        try {
          stat = fs.statSync(abs);
        } catch (er) {
          stat = lstat;
        }
      } else {
        stat = lstat;
      }
    }
    this.statCache[abs] = stat;
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return false;
    return c;
  };
  GlobSync.prototype._mark = function(p) {
    return common.mark(this, p);
  };
  GlobSync.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
  };
});

// ../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS((exports2, module2) => {
  module2.exports = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
});

// ../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js
var require_once = __commonJS((exports2, module2) => {
  var wrappy = require_wrappy();
  module2.exports = wrappy(once);
  module2.exports.strict = wrappy(onceStrict);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
});

// ../../node_modules/.pnpm/inflight@1.0.6/node_modules/inflight/inflight.js
var require_inflight = __commonJS((exports2, module2) => {
  var wrappy = require_wrappy();
  var reqs = Object.create(null);
  var once = require_once();
  module2.exports = wrappy(inflight);
  function inflight(key, cb) {
    if (reqs[key]) {
      reqs[key].push(cb);
      return null;
    } else {
      reqs[key] = [cb];
      return makeres(key);
    }
  }
  function makeres(key) {
    return once(function RES() {
      var cbs = reqs[key];
      var len = cbs.length;
      var args = slice(arguments);
      try {
        for (var i = 0; i < len; i++) {
          cbs[i].apply(null, args);
        }
      } finally {
        if (cbs.length > len) {
          cbs.splice(0, len);
          process.nextTick(function() {
            RES.apply(null, args);
          });
        } else {
          delete reqs[key];
        }
      }
    });
  }
  function slice(args) {
    var length = args.length;
    var array = [];
    for (var i = 0; i < length; i++)
      array[i] = args[i];
    return array;
  }
});

// ../../node_modules/.pnpm/glob@7.1.6/node_modules/glob/glob.js
var require_glob = __commonJS((exports2, module2) => {
  module2.exports = glob;
  var fs = require("fs");
  var rp = require_fs();
  var minimatch = require_minimatch();
  var Minimatch = minimatch.Minimatch;
  var inherits = require_inherits();
  var EE = require("events").EventEmitter;
  var path2 = require("path");
  var assert = require("assert");
  var isAbsolute = require_path_is_absolute();
  var globSync = require_sync();
  var common = require_common();
  var alphasort = common.alphasort;
  var alphasorti = common.alphasorti;
  var setopts = common.setopts;
  var ownProp = common.ownProp;
  var inflight = require_inflight();
  var util = require("util");
  var childrenIgnored = common.childrenIgnored;
  var isIgnored = common.isIgnored;
  var once = require_once();
  function glob(pattern, options, cb) {
    if (typeof options === "function")
      cb = options, options = {};
    if (!options)
      options = {};
    if (options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern, options);
    }
    return new Glob(pattern, options, cb);
  }
  glob.sync = globSync;
  var GlobSync = glob.GlobSync = globSync.GlobSync;
  glob.glob = glob;
  function extend(origin, add) {
    if (add === null || typeof add !== "object") {
      return origin;
    }
    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }
  glob.hasMagic = function(pattern, options_) {
    var options = extend({}, options_);
    options.noprocess = true;
    var g = new Glob(pattern, options);
    var set = g.minimatch.set;
    if (!pattern)
      return false;
    if (set.length > 1)
      return true;
    for (var j = 0; j < set[0].length; j++) {
      if (typeof set[0][j] !== "string")
        return true;
    }
    return false;
  };
  glob.Glob = Glob;
  inherits(Glob, EE);
  function Glob(pattern, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = null;
    }
    if (options && options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern, options);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern, options, cb);
    setopts(this, pattern, options);
    this._didRealPath = false;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    if (typeof cb === "function") {
      cb = once(cb);
      this.on("error", cb);
      this.on("end", function(matches) {
        cb(null, matches);
      });
    }
    var self = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess)
      return this;
    if (n === 0)
      return done();
    var sync = true;
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false, done);
    }
    sync = false;
    function done() {
      --self._processing;
      if (self._processing <= 0) {
        if (sync) {
          process.nextTick(function() {
            self._finish();
          });
        } else {
          self._finish();
        }
      }
    }
  }
  Glob.prototype._finish = function() {
    assert(this instanceof Glob);
    if (this.aborted)
      return;
    if (this.realpath && !this._didRealpath)
      return this._realpath();
    common.finish(this);
    this.emit("end", this.found);
  };
  Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    var self = this;
    for (var i = 0; i < this.matches.length; i++)
      this._realpathSet(i, next);
    function next() {
      if (--n === 0)
        self._finish();
    }
  };
  Glob.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset);
    var self = this;
    var n = found.length;
    if (n === 0)
      return cb();
    var set = this.matches[index] = Object.create(null);
    found.forEach(function(p, i) {
      p = self._makeAbs(p);
      rp.realpath(p, self.realpathCache, function(er, real) {
        if (!er)
          set[real] = true;
        else if (er.syscall === "stat")
          set[p] = true;
        else
          self.emit("error", er);
        if (--n === 0) {
          self.matches[index] = set;
          cb();
        }
      });
    });
  };
  Glob.prototype._mark = function(p) {
    return common.mark(this, p);
  };
  Glob.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
  };
  Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit("abort");
  };
  Glob.prototype.pause = function() {
    if (!this.paused) {
      this.paused = true;
      this.emit("pause");
    }
  };
  Glob.prototype.resume = function() {
    if (this.paused) {
      this.emit("resume");
      this.paused = false;
      if (this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i = 0; i < eq.length; i++) {
          var e = eq[i];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i = 0; i < pq.length; i++) {
          var p = pq[i];
          this._processing--;
          this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  };
  Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
    assert(this instanceof Glob);
    assert(typeof cb === "function");
    if (this.aborted)
      return;
    this._processing++;
    if (this.paused) {
      this._processQueue.push([pattern, index, inGlobStar, cb]);
      return;
    }
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index, cb);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return cb();
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
  };
  Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path2.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return cb();
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix) {
        if (prefix !== "/")
          e = prefix + "/" + e;
        else
          e = prefix + e;
      }
      this._process([e].concat(remain), index, inGlobStar, cb);
    }
    cb();
  };
  Glob.prototype._emitMatch = function(index, e) {
    if (this.aborted)
      return;
    if (isIgnored(this, e))
      return;
    if (this.paused) {
      this._emitQueue.push([index, e]);
      return;
    }
    var abs = isAbsolute(e) ? e : this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute)
      e = abs;
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    var st = this.statCache[abs];
    if (st)
      this.emit("stat", e, st);
    this.emit("match", e);
  };
  Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, false, cb);
    var lstatkey = "lstat\0" + abs;
    var self = this;
    var lstatcb = inflight(lstatkey, lstatcb_);
    if (lstatcb)
      fs.lstat(abs, lstatcb);
    function lstatcb_(er, lstat) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat && lstat.isSymbolicLink();
      self.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory()) {
        self.cache[abs] = "FILE";
        cb();
      } else
        self._readdir(abs, false, cb);
    }
  };
  Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (this.aborted)
      return;
    cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
    if (!cb)
      return;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs, cb);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return cb();
      if (Array.isArray(c))
        return cb(null, c);
    }
    var self = this;
    fs.readdir(abs, readdirCb(this, abs, cb));
  };
  function readdirCb(self, abs, cb) {
    return function(er, entries) {
      if (er)
        self._readdirError(abs, er, cb);
      else
        self._readdirEntries(abs, entries, cb);
    };
  }
  Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (this.aborted)
      return;
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return cb(null, entries);
  };
  Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted)
      return;
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + " invalid cwd " + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          this.emit("error", error);
          this.abort();
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict) {
          this.emit("error", er);
          this.abort();
        }
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
    return cb();
  };
  Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false, cb);
    var isSym = this.symlinks[abs];
    var len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true, cb);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true, cb);
    }
    cb();
  };
  Glob.prototype._processSimple = function(prefix, index, cb) {
    var self = this;
    this._stat(prefix, function(er, exists) {
      self._processSimple2(prefix, index, er, exists, cb);
    });
  };
  Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists)
      return cb();
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path2.join(this.root, prefix);
      } else {
        prefix = path2.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
    cb();
  };
  Glob.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return cb(null, c);
      if (needDir && c === "FILE")
        return cb();
    }
    var exists;
    var stat = this.statCache[abs];
    if (stat !== void 0) {
      if (stat === false)
        return cb(null, stat);
      else {
        var type = stat.isDirectory() ? "DIR" : "FILE";
        if (needDir && type === "FILE")
          return cb();
        else
          return cb(null, type, stat);
      }
    }
    var self = this;
    var statcb = inflight("stat\0" + abs, lstatcb_);
    if (statcb)
      fs.lstat(abs, statcb);
    function lstatcb_(er, lstat) {
      if (lstat && lstat.isSymbolicLink()) {
        return fs.stat(abs, function(er2, stat2) {
          if (er2)
            self._stat2(f, abs, null, lstat, cb);
          else
            self._stat2(f, abs, er2, stat2, cb);
        });
      } else {
        self._stat2(f, abs, er, lstat, cb);
      }
    }
  };
  Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
      this.statCache[abs] = false;
      return cb();
    }
    var needDir = f.slice(-1) === "/";
    this.statCache[abs] = stat;
    if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
      return cb(null, false, stat);
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return cb();
    return cb(null, c, stat);
  };
});

// ../../node_modules/.pnpm/rimraf@3.0.2/node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS((exports2, module2) => {
  var assert = require("assert");
  var path2 = require("path");
  var fs = require("fs");
  var glob = void 0;
  try {
    glob = require_glob();
  } catch (_err) {
  }
  var defaultGlobOpts = {
    nosort: true,
    silent: true
  };
  var timeout = 0;
  var isWindows = process.platform === "win32";
  var defaults = (options) => {
    const methods = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods.forEach((m) => {
      options[m] = options[m] || fs[m];
      m = m + "Sync";
      options[m] = options[m] || fs[m];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
    options.emfileWait = options.emfileWait || 1e3;
    if (options.glob === false) {
      options.disableGlob = true;
    }
    if (options.disableGlob !== true && glob === void 0) {
      throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
    }
    options.disableGlob = options.disableGlob || false;
    options.glob = options.glob || defaultGlobOpts;
  };
  var rimraf = (p, options, cb) => {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert.equal(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    defaults(options);
    let busyTries = 0;
    let errState = null;
    let n = 0;
    const next = (er) => {
      errState = errState || er;
      if (--n === 0)
        cb(errState);
    };
    const afterGlob = (er, results) => {
      if (er)
        return cb(er);
      n = results.length;
      if (n === 0)
        return cb();
      results.forEach((p2) => {
        const CB = (er2) => {
          if (er2) {
            if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
              busyTries++;
              return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
            }
            if (er2.code === "EMFILE" && timeout < options.emfileWait) {
              return setTimeout(() => rimraf_(p2, options, CB), timeout++);
            }
            if (er2.code === "ENOENT")
              er2 = null;
          }
          timeout = 0;
          next(er2);
        };
        rimraf_(p2, options, CB);
      });
    };
    if (options.disableGlob || !glob.hasMagic(p))
      return afterGlob(null, [p]);
    options.lstat(p, (er, stat) => {
      if (!er)
        return afterGlob(null, [p]);
      glob(p, options.glob, afterGlob);
    });
  };
  var rimraf_ = (p, options, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT")
        return cb(null);
      if (er && er.code === "EPERM" && isWindows)
        fixWinEPERM(p, options, er, cb);
      if (st && st.isDirectory())
        return rmdir(p, options, er, cb);
      options.unlink(p, (er2) => {
        if (er2) {
          if (er2.code === "ENOENT")
            return cb(null);
          if (er2.code === "EPERM")
            return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          if (er2.code === "EISDIR")
            return rmdir(p, options, er2, cb);
        }
        return cb(er2);
      });
    });
  };
  var fixWinEPERM = (p, options, er, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.chmod(p, 438, (er2) => {
      if (er2)
        cb(er2.code === "ENOENT" ? null : er);
      else
        options.stat(p, (er3, stats) => {
          if (er3)
            cb(er3.code === "ENOENT" ? null : er);
          else if (stats.isDirectory())
            rmdir(p, options, er, cb);
          else
            options.unlink(p, cb);
        });
    });
  };
  var fixWinEPERMSync = (p, options, er) => {
    assert(p);
    assert(options);
    try {
      options.chmodSync(p, 438);
    } catch (er2) {
      if (er2.code === "ENOENT")
        return;
      else
        throw er;
    }
    let stats;
    try {
      stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT")
        return;
      else
        throw er;
    }
    if (stats.isDirectory())
      rmdirSync(p, options, er);
    else
      options.unlinkSync(p);
  };
  var rmdir = (p, options, originalEr, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.rmdir(p, (er) => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
        rmkids(p, options, cb);
      else if (er && er.code === "ENOTDIR")
        cb(originalEr);
      else
        cb(er);
    });
  };
  var rmkids = (p, options, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, (er, files) => {
      if (er)
        return cb(er);
      let n = files.length;
      if (n === 0)
        return options.rmdir(p, cb);
      let errState;
      files.forEach((f) => {
        rimraf(path2.join(p, f), options, (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--n === 0)
            options.rmdir(p, cb);
        });
      });
    });
  };
  var rimrafSync = (p, options) => {
    options = options || {};
    defaults(options);
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    let results;
    if (options.disableGlob || !glob.hasMagic(p)) {
      results = [p];
    } else {
      try {
        options.lstatSync(p);
        results = [p];
      } catch (er) {
        results = glob.sync(p, options.glob);
      }
    }
    if (!results.length)
      return;
    for (let i = 0; i < results.length; i++) {
      const p2 = results[i];
      let st;
      try {
        st = options.lstatSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM" && isWindows)
          fixWinEPERMSync(p2, options, er);
      }
      try {
        if (st && st.isDirectory())
          rmdirSync(p2, options, null);
        else
          options.unlinkSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM")
          return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
        if (er.code !== "EISDIR")
          throw er;
        rmdirSync(p2, options, er);
      }
    }
  };
  var rmdirSync = (p, options, originalEr) => {
    assert(p);
    assert(options);
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      if (er.code === "ENOTDIR")
        throw originalEr;
      if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
        rmkidsSync(p, options);
    }
  };
  var rmkidsSync = (p, options) => {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f) => rimrafSync(path2.join(p, f), options));
    const retries = isWindows ? 100 : 1;
    let i = 0;
    do {
      let threw = true;
      try {
        const ret = options.rmdirSync(p, options);
        threw = false;
        return ret;
      } finally {
        if (++i < retries && threw)
          continue;
      }
    } while (true);
  };
  module2.exports = rimraf;
  rimraf.sync = rimrafSync;
});

// ../../node_modules/.pnpm/@zkochan#libnpx@11.0.3/node_modules/@zkochan/libnpx/index.js
var require_libnpx = __commonJS((exports2, module2) => {
  "use strict";
  var Buffer2 = require_safe_buffer().Buffer;
  var promisify = require_util().promisify;
  var child = require_child();
  var fs = require("fs");
  var parseArgs = require_parse_args();
  var path2 = require("path");
  var which = promisify(require_which());
  module2.exports = npx2;
  module2.exports.parseArgs = parseArgs;
  function npx2(argv) {
    const shell = argv["shell-auto-fallback"];
    if (shell || shell === "") {
      const fallback = require_auto_fallback()(shell, process.env.SHELL, argv);
      if (fallback) {
        return console.log(fallback);
      } else {
        process.exitCode = 1;
        return;
      }
    }
    if (!argv.call && (!argv.command || !argv.package)) {
      !argv.q && console.error(Y()`\nERROR: You must supply a command.\n`);
      !argv.q && parseArgs.showHelp();
      process.exitCode = 1;
      return;
    }
    const startTime = Date.now();
    return localBinPath(process.cwd()).then((local) => {
      if (local) {
        process.env.PATH = `${local}${path2.delimiter}${process.env.PATH}`;
      }
      return Promise.all([
        argv.command && getExistingPath(argv.command, argv),
        argv.call && local && getEnv(argv)
      ]).then((args) => {
        const existing = args[0];
        const newEnv = args[1];
        if (newEnv) {
          Object.assign(process.env, newEnv);
        }
        if (!existing && !argv.call || argv.packageRequested) {
          return ensurePackages(argv.package, argv).then((results) => {
            if (results && results.added && results.updated && !argv.q) {
              console.error(Y()`npx: installed ${results.added.length + results.updated.length} in ${(Date.now() - startTime) / 1e3}s`);
            }
            if (argv.command && !existing && !argv.packageRequested && argv.package.length === 1) {
              return promisify(fs.readdir)(results.bin).then((bins) => {
                if (process.platform === "win32") {
                  bins = bins.filter((b) => b !== "etc" && b !== "node_modules");
                }
                if (bins.length < 1) {
                  throw new Error(Y()`command not found: ${argv.command}`);
                }
                const cmd = new RegExp(`^${argv.command}(?:\\.cmd)?$`, "i");
                const matching = bins.find((b) => b.match(cmd));
                return path2.resolve(results.bin, bins[matching] || bins[0]);
              }, (err) => {
                if (err.code === "ENOENT") {
                  throw new Error(Y()`command not found: ${argv.command}`);
                } else {
                  throw err;
                }
              });
            } else {
              return existing;
            }
          });
        } else {
          return existing;
        }
      }).then((existing) => {
        return execCommand(existing, argv);
      }).catch((err) => {
        !argv.q && console.error(err.message);
        process.exitCode = err.exitCode || 1;
      });
    });
  }
  module2.exports._localBinPath = localBinPath;
  function localBinPath(cwd) {
    return require_get_prefix()(cwd).then((prefix) => {
      return prefix && path2.join(prefix, "node_modules", ".bin");
    });
  }
  module2.exports._getEnv = getEnv;
  function getEnv(opts) {
    const args = ["run", "env", "--parseable"];
    return findNodeScript(opts.npm, {isLocal: true}).then((npmPath) => {
      if (npmPath) {
        args.unshift(child.escapeArg(opts.npm));
        return process.argv[0];
      } else {
        return opts.npm;
      }
    }).then((npmPath) => {
      return child.exec(npmPath, args);
    }).then(require_main().parse);
  }
  module2.exports._ensurePackages = ensurePackages;
  function ensurePackages(specs, opts) {
    return (opts.cache ? Promise.resolve(opts.cache) : getNpmCache(opts)).then((cache) => {
      const prefix = path2.join(cache, "_npx", process.pid.toString());
      const bins = process.platform === "win32" ? prefix : path2.join(prefix, "bin");
      const rimraf = require_rimraf();
      process.on("exit", () => rimraf.sync(prefix));
      return promisify(rimraf)(bins).then(() => {
        return installPackages(specs, prefix, opts);
      }).then((info) => {
        process.env.PATH = `${bins}${path2.delimiter}${process.env.PATH}`;
        if (!info) {
          info = {};
        }
        info.prefix = prefix;
        info.bin = bins;
        return info;
      });
    });
  }
  module2.exports._getExistingPath = getExistingPath;
  function getExistingPath(command, opts) {
    if (opts.isLocal) {
      return Promise.resolve(command);
    } else if (opts.cmdHadVersion || opts.packageRequested || opts.ignoreExisting) {
      return Promise.resolve(false);
    } else {
      return which(command).catch((err) => {
        if (err.code === "ENOENT") {
          if (opts.install === false) {
            err.exitCode = 127;
            throw err;
          }
        } else {
          throw err;
        }
      });
    }
  }
  module2.exports._getNpmCache = getNpmCache;
  function getNpmCache(opts) {
    const args = ["config", "get", "cache", "--parseable"];
    if (opts.userconfig) {
      args.push("--userconfig", child.escapeArg(opts.userconfig, true));
    }
    return findNodeScript(opts.npm, {isLocal: true}).then((npmPath) => {
      if (npmPath) {
        args.unshift(child.escapeArg(opts.npm));
        return process.argv[0];
      } else {
        return opts.npm;
      }
    }).then((npmPath) => {
      return child.exec(npmPath, args);
    }).then((cache) => cache.trim());
  }
  module2.exports._buildArgs = buildArgs;
  function buildArgs(specs, prefix, opts) {
    const args = ["install"].concat(specs);
    args.push("--global", "--prefix", prefix);
    if (opts.cache)
      args.push("--cache", opts.cache);
    if (opts.userconfig)
      args.push("--userconfig", opts.userconfig);
    return args;
  }
  module2.exports._installPackages = installPackages;
  function installPackages(specs, prefix, opts) {
    const args = buildArgs(specs, prefix, opts);
    return findNodeScript(opts.npm, {isLocal: true}).then((npmPath) => {
      if (npmPath) {
        args.unshift(process.platform === "win32" ? child.escapeArg(opts.npm) : opts.npm);
        return process.argv[0];
      } else {
        return opts.npm;
      }
    }).then((npmPath) => {
      return process.platform === "win32" ? child.escapeArg(npmPath, true) : npmPath;
    }).then((npmPath) => {
      return child.spawn(npmPath, args, {
        stdio: opts.installerStdio ? opts.installerStdio : [0, "pipe", opts.q ? "ignore" : 2]
      }).then((deets) => {
        try {
          return deets.stdout ? JSON.parse(deets.stdout) : null;
        } catch (e) {
        }
      }, (err) => {
        if (err.exitCode) {
          err.message = Y()`Install for ${specs} failed with code ${err.exitCode}`;
        }
        throw err;
      });
    });
  }
  module2.exports._execCommand = execCommand;
  function execCommand(_existing, argv) {
    return findNodeScript(_existing, argv).then((existing) => {
      const argvCmdOpts = argv.cmdOpts || [];
      if (existing && !argv.alwaysSpawn && !argv.nodeArg && !argv.shell && existing !== process.argv[1]) {
        const Module = require("module");
        if (!argv.noYargs) {
          require_yargs3().reset();
        }
        process.argv = [
          process.argv[0],
          existing
        ].concat(argvCmdOpts);
        Module.runMain();
      } else if (!existing && argv.nodeArg && argv.nodeArg.length) {
        throw new Error(Y()`ERROR: --node-arg/-n can only be used on packages with node scripts.`);
      } else {
        let cmd = existing;
        let cmdOpts = argvCmdOpts;
        if (existing) {
          cmd = process.argv[0];
          if (process.platform === "win32") {
            cmd = child.escapeArg(cmd, true);
          }
          cmdOpts = argv.nodeArg;
          if (cmdOpts) {
            cmdOpts = Array.isArray(cmdOpts) ? cmdOpts : [cmdOpts];
          } else {
            cmdOpts = [];
          }
          cmdOpts = cmdOpts.reduce((acc, arg) => {
            return acc.concat(arg.split(/\s+/));
          }, []);
          cmdOpts = cmdOpts.concat(existing, argvCmdOpts);
        }
        const opts = Object.assign({}, argv, {cmdOpts});
        return child.runCommand(cmd, opts).catch((err) => {
          if (err.isOperational && err.exitCode) {
            process.exitCode = err.exitCode;
          } else {
            throw err;
          }
        });
      }
    });
  }
  module2.exports._findNodeScript = findNodeScript;
  function findNodeScript(existing, opts) {
    if (!existing) {
      return Promise.resolve(false);
    } else {
      return promisify(fs.stat)(existing).then((stat) => {
        if (opts && opts.isLocal && path2.extname(existing) === ".js") {
          return existing;
        } else if (opts && opts.isLocal && stat.isDirectory()) {
          try {
            const pkg = require(path2.resolve(existing, "package.json"));
            const target = path2.resolve(existing, pkg.bin || pkg.main || "index.js");
            return findNodeScript(target, opts).then((script) => {
              if (script) {
                return script;
              } else {
                throw new Error(Y()`command not found: ${target}`);
              }
            });
          } catch (e) {
            throw new Error(Y()`command not found: ${existing}`);
          }
        } else if (process.platform !== "win32") {
          const bytecount = 400;
          const buf = Buffer2.alloc(bytecount);
          return promisify(fs.open)(existing, "r").then((fd) => {
            return promisify(fs.read)(fd, buf, 0, bytecount, 0).then(() => {
              return promisify(fs.close)(fd);
            }, (err) => {
              return promisify(fs.close)(fd).then(() => {
                throw err;
              });
            });
          }).then(() => {
            const re = /#!\s*(?:\/usr\/bin\/env\s*node|\/usr\/local\/bin\/node|\/usr\/bin\/node)\s*\r?\n/i;
            return buf.toString("utf8").match(re) && existing;
          });
        } else if (process.platform === "win32") {
          const buf = Buffer2.alloc(1e3);
          return promisify(fs.open)(existing, "r").then((fd) => {
            return promisify(fs.read)(fd, buf, 0, 1e3, 0).then(() => {
              return promisify(fs.close)(fd);
            }, (err) => {
              return promisify(fs.close)(fd).then(() => {
                throw err;
              });
            });
          }).then(() => {
            return buf.toString("utf8").trim();
          }).then((str) => {
            const cmd = /"%~dp0\\node\.exe"\s+"%~dp0\\(.*)"\s+%\*/;
            const mingw = /"\$basedir\/node"\s+"\$basedir\/(.*)"\s+"\$@"/i;
            return str.match(cmd) || str.match(mingw);
          }).then((match) => {
            return match && path2.join(path2.dirname(existing), match[1]);
          });
        }
      });
    }
  }
  function Y() {
    return require_y();
  }
});

// ../../node_modules/.pnpm/path-name@1.0.0/node_modules/path-name/index.js
var require_path_name = __commonJS((exports2, module2) => {
  "use strict";
  var PATH2;
  if (process.platform === "win32") {
    PATH2 = "Path";
    Object.keys(process.env).forEach((e) => {
      if (e.match(/^PATH$/i)) {
        PATH2 = e;
      }
    });
  } else {
    PATH2 = "PATH";
  }
  module2.exports = PATH2;
});

// lib/pnpx.js
"use strict";
var __importDefault = exports && exports.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {default: mod};
};
Object.defineProperty(exports, "__esModule", {value: true});
var find_workspace_dir_1 = __importDefault(require_lib2());
var path = require("path");
var npx = require_libnpx();
var PATH = require_path_name();
var PNPM_PATH = path.join(__dirname, "pnpm.js");
(async () => {
  var _a;
  const workspaceRoot = await find_workspace_dir_1.default(process.cwd());
  if (workspaceRoot) {
    process.env[PATH] = `${path.join(workspaceRoot, "node_modules/.bin")}${path.delimiter}${(_a = process.env[PATH]) !== null && _a !== void 0 ? _a : ""}`;
  }
  npx({
    ...npx.parseArgs(process.argv, PNPM_PATH),
    installerStdio: "inherit"
  });
})();
